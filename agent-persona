#!/usr/bin/env bash
# shellcheck disable=SC2015
set -euo pipefail

# agent-persona — tool-agnostic persona launcher for AI coding agents
# https://github.com/GoodFarming/agent-persona
#
# Usage:
#   agent-persona <tool> <persona> [--] [tool args...]
#   agent-persona init              # scaffold .personas/ in current repo
#   agent-persona doctor            # verify install, check for orphaned state
#   agent-persona recover           # restore AGENTS.md from backup after hard-kill
#   agent-persona which <persona>   # show resolved paths without launching
#   agent-persona --list            # list available personas
#   agent-persona --version         # show version
#
# Tool-specific shims:
#   codex-persona <persona>         # launches codex
#   claude-persona <persona>        # launches claude (overlays CLAUDE.md)
#   gemini-persona <persona>        # launches gemini (overlays GEMINI.md)
#
# Overlay behavior (Linux):
#   - With unshare: bind-mount overlay (no on-disk change)
#   - Without unshare: swap-and-restore (small risk on hard-kill; use 'recover')

VERSION="1.1.0"

DEBUG_FLAG="${AGENT_PERSONA_DEBUG:-}"
log() { [[ -n "$DEBUG_FLAG" ]] && echo "[agent-persona] $*" >&2 || true; }
die() { echo "[agent-persona] error: $*" >&2; exit 1; }
warn() { echo "[agent-persona] warning: $*" >&2; }
info() { echo "[agent-persona] $*" >&2; }

# --- Configuration (env vars with CLI flag overrides) ---
META_ENABLED="${AGENT_PERSONA_META:-1}"
META_FILE_OVERRIDE="${AGENT_PERSONA_META_FILE:-}"
META_POSITION="${AGENT_PERSONA_META_POSITION:-top}"
FORCE_SWAP="${AGENT_PERSONA_FORCE_SWAP:-0}"
MCP_ENABLED="${AGENT_PERSONA_MCP:-1}"

meta_tmp=""
cleanup_meta() { [[ -n "${meta_tmp:-}" ]] && rm -f "$meta_tmp" 2>/dev/null || true; }

default_meta_template() {
  cat <<'META'
# Repo-Wide Agent Instructions

These instructions apply to ALL personas launched in this repository.

## Project Context
<!-- Add project-specific context here -->

## Conventions
<!-- Add coding conventions, style guides, etc. -->
META
}

meta_is_unedited_template() {
  local meta_path="$1"
  [[ -f "$meta_path" ]] || return 1
  # Treat the init-generated meta template as "no meta" until the user edits it.
  local file_content template_content
  file_content="$(tr -d '\r' < "$meta_path" | sed -e 's/[ \t]*$//' )"
  template_content="$(default_meta_template | tr -d '\r' | sed -e 's/[ \t]*$//' )"
  [[ "$file_content" == "$template_content" ]]
}

# --- MCP temp config (Claude) ---
mcp_config_file=""
cleanup_mcp() { [[ -n "${mcp_config_file:-}" && -f "$mcp_config_file" ]] && rm -f "$mcp_config_file" 2>/dev/null || true; }

# --- Policy temp config files ---
claude_settings_file=""
gemini_settings_file=""
opencode_config_file=""
cleanup_policy() {
  [[ -n "${claude_settings_file:-}" && -f "$claude_settings_file" ]] && rm -f "$claude_settings_file" 2>/dev/null || true
  [[ -n "${gemini_settings_file:-}" && -f "$gemini_settings_file" ]] && rm -f "$gemini_settings_file" 2>/dev/null || true
  [[ -n "${opencode_config_file:-}" && -f "$opencode_config_file" ]] && rm -f "$opencode_config_file" 2>/dev/null || true
}

# --- Policy configuration ---
STRICT_POLICY="${AGENT_PERSONA_STRICT_POLICY:-0}"

# --- Swap-and-restore state (fallback when unshare unavailable) ---
swap_active=0
swap_restored=0
swap_prev_kind="none"   # none|file|symlink
swap_prev_target=""
swap_prev_backup=""
swap_backup_meta=""
swap_overlay_path=""

swap_restore() {
  [[ "${swap_active:-0}" == "1" ]] || return 0
  [[ "${swap_restored:-0}" == "0" ]] || return 0
  swap_restored=1

  case "${swap_prev_kind:-none}" in
    symlink)
      [[ -n "${swap_prev_target:-}" && -n "${swap_overlay_path:-}" ]] && \
        ln -sfn "$swap_prev_target" "$swap_overlay_path" 2>/dev/null || true
      ;;
    file)
      if [[ -n "${swap_prev_backup:-}" && -f "$swap_prev_backup" && -n "${swap_overlay_path:-}" ]]; then
        if cp -a --remove-destination "$swap_prev_backup" "$swap_overlay_path" 2>/dev/null; then
          rm -f "$swap_prev_backup" "${swap_backup_meta:-}" 2>/dev/null || true
        elif { rm -f "$swap_overlay_path" 2>/dev/null || true; cp -a "$swap_prev_backup" "$swap_overlay_path" 2>/dev/null; }; then
          rm -f "$swap_prev_backup" "${swap_backup_meta:-}" 2>/dev/null || true
        fi
      fi
      ;;
    none)
      [[ -n "${swap_overlay_path:-}" ]] && rm -f "$swap_overlay_path" 2>/dev/null || true
      ;;
  esac

  swap_active=0
}

cleanup_session() {
  set +e
  swap_restore
  cleanup_meta
  cleanup_mcp
  cleanup_policy
}
trap cleanup_session EXIT INT TERM

# --- Backup/recovery state directory ---
STATE_DIR="${AGENT_PERSONA_STATE_DIR:-${TMPDIR:-/tmp}/agent-persona-state}"
mkdir -p "$STATE_DIR" 2>/dev/null || true

resolve_repo_root() {
  local dir="${1:-$(pwd)}"
  # Convert to absolute path to avoid infinite loop with relative paths
  dir="$(cd "$dir" 2>/dev/null && pwd -P)" || return 1

  if command -v git >/dev/null 2>&1; then
    local git_root
    git_root="$(cd "$dir" && git rev-parse --show-toplevel 2>/dev/null || true)"
    [[ -n "$git_root" ]] && { echo "$git_root"; return 0; }
  fi
  while true; do
    if [[ -d "$dir/.git" || -f "$dir/.git" ]]; then echo "$dir"; return 0; fi
    [[ "$dir" == "/" ]] && break
    dir="$(dirname -- "$dir")"
  done
  return 1
}

# --- persona.json helpers ---
defaults_from_json() {
  local json_path="$1"; local tool_key="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_key" <<'PY' || true
import json, sys
path, tool = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

defaults = []
if isinstance(j.get("defaults"), dict):
    d = j["defaults"]
    # Global defaults (synonyms): global, *, any (first match wins)
    for k in ("global", "*", "any"):
        v = d.get(k)
        if isinstance(v, list):
            defaults.extend([x for x in v if isinstance(x, str)])
            break
    # Tool-specific defaults appended last (wins on conflicts)
    v = d.get(tool)
    if isinstance(v, list):
        defaults.extend([x for x in v if isinstance(x, str)])

for a in defaults:
    print(a)
PY
}

extract_mcp_config() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

# Support both "mcp" and "mcpServers" at top level
mcp_servers = None
if isinstance(j.get("mcp"), dict):
    m = j["mcp"]
    mcp_servers = m.get("servers") or m.get("mcpServers")
elif isinstance(j.get("mcpServers"), dict):
    mcp_servers = j["mcpServers"]

if not isinstance(mcp_servers, dict) or not mcp_servers:
    sys.exit(0)

config = {"mcpServers": mcp_servers}
fd, tmp_path = tempfile.mkstemp(prefix="persona-mcp-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(config, f)
print(tmp_path)
PY
}

codex_mcp_overrides_from_json() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, re, sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

def get_mcp_servers(doc):
    if isinstance(doc.get("mcp"), dict):
        m = doc["mcp"]
        v = m.get("servers") or m.get("mcpServers")
        if isinstance(v, dict):
            return v
    if isinstance(doc.get("mcpServers"), dict):
        return doc["mcpServers"]
    return None

mcp_servers = get_mcp_servers(j)
if not isinstance(mcp_servers, dict) or not mcp_servers:
    sys.exit(0)

def toml_value(v):
    # JSON syntax is valid TOML for strings, arrays, booleans, and numbers.
    return json.dumps(v)

def emit(key, value):
    print(f"{key}={toml_value(value)}")

name_re = re.compile(r"^[A-Za-z0-9_]+$")
env_key_re = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")

for name, cfg in mcp_servers.items():
    if not isinstance(name, str) or not name_re.match(name):
        continue
    if not isinstance(cfg, dict):
        continue

    enabled = cfg.get("enabled")
    emit(f"mcp_servers.{name}.enabled", bool(enabled) if isinstance(enabled, bool) else True)

    # HTTP (streamable) servers
    if isinstance(cfg.get("url"), str):
        emit(f"mcp_servers.{name}.url", cfg["url"])
        btev = cfg.get("bearer_token_env_var") or cfg.get("bearerTokenEnvVar")
        if isinstance(btev, str) and btev:
            emit(f"mcp_servers.{name}.bearer_token_env_var", btev)
        continue

    # Stdio servers
    if isinstance(cfg.get("command"), str):
        emit(f"mcp_servers.{name}.command", cfg["command"])
    if isinstance(cfg.get("args"), list) and all(isinstance(x, str) for x in cfg["args"]):
        emit(f"mcp_servers.{name}.args", cfg["args"])
    if isinstance(cfg.get("cwd"), str):
        emit(f"mcp_servers.{name}.cwd", cfg["cwd"])
    if isinstance(cfg.get("env"), dict):
        for k, v in cfg["env"].items():
            if isinstance(k, str) and env_key_re.match(k):
                emit(f"mcp_servers.{name}.env.{k}", str(v))
PY
}

# --- Policy translation: extract policy from persona.json ---
extract_policy() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy")
if not isinstance(policy, dict):
    sys.exit(0)

# Output policy as JSON for downstream processing
print(json.dumps(policy))
PY
}

# --- Policy translation: get tools.allow list for a tool ---
policy_tools_allow() {
  local json_path="$1" tool_family="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_family" <<'PY' || true
import json, sys

path, tool_family = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
tools = policy.get("tools", {})
allow = tools.get("allow", [])
if not isinstance(allow, list):
    sys.exit(0)

# Tool name emit mapping (canonical -> tool-specific)
EMIT_MAPS = {
    "claude": {
        "bash": "Bash", "read": "Read", "write": "Write", "edit": "Edit",
        "glob": "Glob", "grep": "Grep", "webfetch": "WebFetch",
        "websearch": "WebSearch", "task": "Task", "todowrite": "TodoWrite",
        "notebookedit": "NotebookEdit", "askuserquestion": "AskUserQuestion",
    },
    "gemini": {
        "bash": "shell", "read": "read_file", "write": "write_file",
        "edit": "edit_file", "glob": "glob", "grep": "grep",
    },
    "opencode": {
        "bash": "bash", "read": "read", "write": "write", "edit": "edit",
        "glob": "glob", "grep": "grep", "webfetch": "webfetch",
        "websearch": "websearch",
    },
}

emit_map = EMIT_MAPS.get(tool_family, {})
for tool in allow:
    canonical = tool.lower()
    emitted = emit_map.get(canonical, canonical)
    print(emitted)
PY
}

# --- Policy translation: get tools.deny list for a tool ---
policy_tools_deny() {
  local json_path="$1" tool_family="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_family" <<'PY' || true
import json, sys

path, tool_family = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
tools = policy.get("tools", {})
deny = tools.get("deny", [])
if not isinstance(deny, list):
    sys.exit(0)

# Tool name emit mapping (same as allow)
EMIT_MAPS = {
    "claude": {
        "bash": "Bash", "read": "Read", "write": "Write", "edit": "Edit",
        "glob": "Glob", "grep": "Grep", "webfetch": "WebFetch",
        "websearch": "WebSearch", "task": "Task", "todowrite": "TodoWrite",
        "notebookedit": "NotebookEdit", "askuserquestion": "AskUserQuestion",
    },
    "gemini": {
        "bash": "shell", "read": "read_file", "write": "write_file",
        "edit": "edit_file", "glob": "glob", "grep": "grep",
    },
    "opencode": {
        "bash": "bash", "read": "read", "write": "write", "edit": "edit",
        "glob": "glob", "grep": "grep", "webfetch": "webfetch",
        "websearch": "websearch",
    },
}

emit_map = EMIT_MAPS.get(tool_family, {})
for tool in deny:
    canonical = tool.lower()
    emitted = emit_map.get(canonical, canonical)
    print(emitted)
PY
}

# --- Policy translation: generate Claude settings JSON for path deny ---
generate_claude_settings() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
paths = policy.get("paths", {})
deny_paths = paths.get("deny", [])

if not isinstance(deny_paths, list) or not deny_paths:
    sys.exit(0)

# Generate deny rules for each path pattern
deny_rules = []
for p in deny_paths:
    if not isinstance(p, str):
        continue
    # Generate rules for Read, Edit, Write operations on denied paths
    deny_rules.append(f"Read({p})")
    deny_rules.append(f"Edit({p})")
    deny_rules.append(f"Write({p})")

if not deny_rules:
    sys.exit(0)

settings = {"permissions": {"deny": deny_rules}}
fd, tmp_path = tempfile.mkstemp(prefix="persona-claude-settings-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(settings, f)
print(tmp_path)
PY
}

# --- Policy translation: generate Gemini settings JSON ---
generate_gemini_settings() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not policy:
    sys.exit(0)

settings = {"tools": {}, "mcp": {}}

# Tool name mapping for Gemini
GEMINI_MAP = {
    "bash": "shell", "read": "read_file", "write": "write_file",
    "edit": "edit_file", "glob": "glob", "grep": "grep",
}

# tools.allow -> tools.core
tools = policy.get("tools", {})
if isinstance(tools.get("allow"), list):
    core = []
    for t in tools["allow"]:
        canonical = t.lower()
        core.append(GEMINI_MAP.get(canonical, canonical))
    if core:
        settings["tools"]["core"] = core

# tools.deny -> tools.exclude
if isinstance(tools.get("deny"), list):
    exclude = []
    for t in tools["deny"]:
        canonical = t.lower()
        exclude.append(GEMINI_MAP.get(canonical, canonical))
    if exclude:
        settings["tools"]["exclude"] = exclude

# mcpServers.allow/deny
mcp = policy.get("mcpServers", {})
if isinstance(mcp.get("allow"), list) and mcp["allow"]:
    settings["mcp"]["allowed"] = mcp["allow"]
if isinstance(mcp.get("deny"), list) and mcp["deny"]:
    settings["mcp"]["excluded"] = mcp["deny"]

# Only write if we have something
if not settings["tools"] and not settings["mcp"]:
    sys.exit(0)

fd, tmp_path = tempfile.mkstemp(prefix="persona-gemini-settings-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(settings, f)
print(tmp_path)
PY
}

# --- Policy translation: generate OpenCode config JSON ---
generate_opencode_config() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not policy:
    sys.exit(0)

config = {"tools": {}, "permission": {}}

# Tool name mapping for OpenCode (mostly lowercase)
OPENCODE_MAP = {
    "bash": "bash", "read": "read", "write": "write", "edit": "edit",
    "glob": "glob", "grep": "grep", "webfetch": "webfetch",
    "websearch": "websearch", "task": "task",
}

tools = policy.get("tools", {})

# tools.allow -> permission: { name: "allow" }
if isinstance(tools.get("allow"), list):
    for t in tools["allow"]:
        canonical = t.lower()
        mapped = OPENCODE_MAP.get(canonical, canonical)
        config["permission"][mapped] = "allow"

# tools.deny -> tools: { name: false }
if isinstance(tools.get("deny"), list):
    for t in tools["deny"]:
        canonical = t.lower()
        mapped = OPENCODE_MAP.get(canonical, canonical)
        config["tools"][mapped] = False

# Only write if we have something
if not config["tools"] and not config["permission"]:
    sys.exit(0)

fd, tmp_path = tempfile.mkstemp(prefix="persona-opencode-config-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(config, f)
print(tmp_path)
PY
}

# --- Policy translation: generate Codex sandbox overrides ---
codex_policy_overrides() {
  local json_path="$1" repo_root="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$repo_root" <<'PY' || true
import json, sys, os

path, repo_root = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not policy:
    sys.exit(0)

overrides = []

# paths.allow -> sandbox_mode + writable_roots
paths = policy.get("paths", {})
if isinstance(paths.get("allow"), list) and paths["allow"]:
    overrides.append('sandbox_mode="workspace-write"')

    # Normalize paths to absolute
    abs_paths = []
    for p in paths["allow"]:
        if not isinstance(p, str):
            continue
        if p.startswith("./"):
            abs_paths.append(os.path.normpath(os.path.join(repo_root, p[2:])))
        elif p.startswith("~/"):
            abs_paths.append(os.path.expanduser(p))
        elif p.startswith("/"):
            abs_paths.append(p)
        else:
            abs_paths.append(os.path.normpath(os.path.join(repo_root, p)))

    if abs_paths:
        overrides.append(f'sandbox_workspace_write.writable_roots={json.dumps(abs_paths)}')

# network.deny -> network_access=false
network = policy.get("network", {})
if isinstance(network.get("deny"), list) and "*" in network["deny"]:
    overrides.append('sandbox_workspace_write.network_access=false')

# tools.deny (websearch) -> features.web_search_request=false
tools = policy.get("tools", {})
if isinstance(tools.get("deny"), list):
    deny_lower = [t.lower() for t in tools["deny"]]
    if "websearch" in deny_lower:
        overrides.append('features.web_search_request=false')

for ov in overrides:
    print(ov)
PY
}

# --- Helper: resolve instruction file (tool-specific or fallback to AGENTS.md) ---
resolve_instruction_file() {
  local persona_dir="$1" overlay_name="$2"
  local tool_specific="$persona_dir/$overlay_name"

  # Use tool-specific file if it exists and we're not already targeting AGENTS.md
  if [[ -f "$tool_specific" && "$overlay_name" != "AGENTS.md" ]]; then
    echo "$tool_specific"
  else
    echo "$persona_dir/AGENTS.md"
  fi
}

# --- Helper: normalize persona directory (handles file-vs-dir profiles) ---
get_persona_dir() {
  local persona_src="$1" profile_type="$2"
  if [[ "$profile_type" == "file" ]]; then
    dirname -- "$persona_src"
  else
    echo "$persona_src"
  fi
}

# --- Helper: check if policy exists in persona.json ---
policy_exists_in_json() {
  local json_path="$1"
  [[ -f "$json_path" ]] || return 1
  grep -qE '"policy"\s*:' "$json_path" 2>/dev/null
}

# --- Helper: filter user args that conflict with policy ---
# Uses index-aware iteration to handle two-token flags (--flag value)
# Outputs null-delimited args for safe array construction
filter_user_args() {
  local tool="$1" has_policy="$2"
  shift 2
  local -a user_args=("$@")

  # If no policy, pass through unchanged
  if [[ "$has_policy" -eq 0 ]]; then
    printf '%s\0' "${user_args[@]}"
    return 0
  fi

  # Policy-controlled flags per tool
  local -a claude_controlled=(
    "--permission-mode"
    "--dangerously-skip-permissions"
    "--tools"
    "--allowedTools"
    "--disallowedTools"
    "--settings"
  )

  local -a codex_controlled_prefixes=(
    "sandbox_mode="
    "sandbox_workspace_write."
    "features.web_search_request"
  )

  local -a codex_controlled_flags=(
    "--dangerously-bypass-approvals-and-sandbox"
    "--yolo"
    "--full-auto"
  )

  local -a filtered=()
  local i=0
  local n=${#user_args[@]}

  while (( i < n )); do
    local arg="${user_args[i]}"
    local skip=0
    local skip_next=0

    case "$tool" in
      claude|claude-code)
        for flag in "${claude_controlled[@]}"; do
          if [[ "$arg" == "$flag" ]]; then
            skip=1
            skip_next=1
            log "filtering policy-controlled flag: $arg ${user_args[i+1]:-}"
            break
          elif [[ "$arg" == "$flag="* ]]; then
            skip=1
            log "filtering policy-controlled flag: $arg"
            break
          fi
        done
        ;;

      codex)
        # Check standalone flags
        for flag in "${codex_controlled_flags[@]}"; do
          if [[ "$arg" == "$flag" ]]; then
            skip=1
            log "filtering policy-controlled flag: $arg"
            break
          fi
        done

        # Check -c config overrides
        if [[ $skip -eq 0 && "$arg" == "-c" ]]; then
          local next="${user_args[i+1]:-}"
          for prefix in "${codex_controlled_prefixes[@]}"; do
            if [[ "$next" == "$prefix"* ]]; then
              skip=1
              skip_next=1
              log "filtering policy-controlled config: -c $next"
              break
            fi
          done
        fi
        ;;

      # Gemini and OpenCode use env vars for config, no CLI flags to filter
    esac

    if (( skip == 0 )); then
      filtered+=("$arg")
    fi

    (( i++ ))
    if (( skip_next == 1 && i < n )); then
      (( i++ ))
    fi
  done

  printf '%s\0' "${filtered[@]}"
}

# --- Subcommand: init ---
cmd_init() {
  local target="${1:-.}"
  local repo_root
  repo_root="$(resolve_repo_root "$target" 2>/dev/null || echo "$target")"

  local personas_dir="$repo_root/.personas"
  local legacy_dir="$repo_root/.persona"

  if [[ -d "$personas_dir" ]]; then
    info ".personas/ already exists at $repo_root"
  else
    mkdir -p "$personas_dir"
    info "Created $personas_dir/"
    [[ -d "$legacy_dir" ]] && info "Note: legacy $legacy_dir/ exists (prefer $personas_dir/)"
  fi

  if [[ ! -f "$personas_dir/meta.AGENTS.md" ]]; then
    # Create a starter meta file (ignored until edited)
    default_meta_template > "$personas_dir/meta.AGENTS.md"
    info "  - meta.AGENTS.md (repo-wide instructions; ignored until edited)"
  else
    info "  - meta.AGENTS.md already exists"
  fi

  if [[ ! -f "$personas_dir/README.md" ]]; then
    cat > "$personas_dir/README.md" <<'README'
# Repo-local personas (`.personas/`)

This repository is set up for repo-local agent personas via `agent-persona`.

## Repo-wide instructions (meta)

- `.personas/meta.AGENTS.md` is merged into every persona launched in this repo.
- The default template created by `agent-persona init` is ignored until you edit it.
- Disable meta merge: `agent-persona ... --no-meta` or `AGENT_PERSONA_META=0`
- Merge position: `--meta-position top|bottom` (default: top)

## Add a persona

Create a folder and an `AGENTS.md`:

```bash
mkdir -p .personas/my-persona
$EDITOR .personas/my-persona/AGENTS.md
```

Optional `persona.json` (defaults + MCP):

```json
{
  "defaults": {
    "codex": ["--full-auto"],
    "claude": ["--permission-mode", "bypassPermissions"]
  },
  "mcpServers": {
    "myserver": {
      "command": "my-mcp-server",
      "args": ["--flag"],
      "env": { "MY_ENV": "value" }
    }
  }
}
```

## Launch

```bash
agent-persona codex my-persona
agent-persona claude my-persona
agent-persona gemini my-persona
```

## Notes

- On Linux, `agent-persona` prefers a bind-mount overlay via `unshare` (no on-disk changes).
- If `unshare` isn’t available, it falls back to swap-and-restore. If you hard-kill the tool, run `agent-persona recover`.
README
    info "  - README.md (how .personas/ works)"
  else
    info "  - README.md already exists"
  fi

  info ""
  info "Next steps:"
  info "  1. Edit .personas/meta.AGENTS.md with your project context"
  info "  2. Add personas: mkdir .personas/my-persona && edit .personas/my-persona/AGENTS.md"
  info "  3. Launch: agent-persona claude my-persona"
}

# --- Subcommand: doctor ---
cmd_doctor() {
  local issues=0

  info "Checking agent-persona installation..."
  echo ""

  # Check Bash version (policy features require Bash 4+)
  local bash_major="${BASH_VERSINFO[0]}"
  if (( bash_major >= 4 )); then
    echo "[ok] Bash $BASH_VERSION (policy features supported)"
  else
    echo "[!!] Bash $BASH_VERSION detected; policy features require Bash 4+"
    issues=$((issues + 1))
  fi

  # Check Python (required for policy enforcement)
  if command -v python3 >/dev/null 2>&1; then
    echo "[ok] Python 3 available (policy enforcement supported)"
  elif command -v python >/dev/null 2>&1; then
    echo "[ok] Python available (policy enforcement supported)"
  else
    echo "[--] Python not found (policy features will be unavailable)"
  fi

  # Check launcher
  if command -v agent-persona >/dev/null 2>&1; then
    echo "[ok] agent-persona found: $(command -v agent-persona)"
  else
    echo "[!!] agent-persona not in PATH"
    issues=$((issues + 1))
  fi

  # Check tool shims
  for shim in codex-persona claude-persona gemini-persona opencode-persona; do
    if command -v "$shim" >/dev/null 2>&1; then
      echo "[ok] $shim found"
    else
      echo "[--] $shim not found (optional)"
    fi
  done

  # Check persona directories
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  echo ""
  info "Checking persona directories..."

  local have_personas=0
  if [[ -d "$HOME/.personas" ]]; then
    local count
    count=$(find "$HOME/.personas" -maxdepth 1 -type d | wc -l)
    echo "[ok] Home personas: $HOME/.personas ($((count - 1)) personas)"
    have_personas=1
  fi
  if [[ -d "$PERSONA_HOME/.personas" ]]; then
    local count
    count=$(find "$PERSONA_HOME/.personas" -maxdepth 1 -type d | wc -l)
    echo "[ok] Installed personas: $PERSONA_HOME/.personas ($((count - 1)) personas)"
    have_personas=1
  fi
  if [[ $have_personas -eq 0 ]]; then
    echo "[--] No persona directories found"
  fi

  # Check for orphaned backups (swap-mode leftovers)
  echo ""
  info "Checking for orphaned state..."

  local orphans=0
  if compgen -G "$STATE_DIR/*.backup" >/dev/null 2>&1; then
    for backup in "$STATE_DIR"/*.backup; do
      [[ -f "$backup" ]] || continue
      echo "[!!] Orphaned backup: $backup"
      orphans=$((orphans + 1))
      issues=$((issues + 1))
    done
  fi

  if [[ $orphans -eq 0 ]]; then
    echo "[ok] No orphaned backups"
  else
    echo ""
    info "Run 'agent-persona recover' to restore orphaned files"
  fi

  # Check unshare capability
  echo ""
  info "Checking overlay mechanism..."

  if command -v unshare >/dev/null 2>&1; then
    # Test if unshare works
    if unshare -Um true 2>/dev/null; then
      echo "[ok] unshare available (bind-mount overlay, no on-disk changes)"
    else
      echo "[--] unshare exists but unprivileged user namespaces disabled"
      echo "     Will use swap-and-restore (has small risk on hard-kill)"
    fi
  else
    echo "[--] unshare not found, will use swap-and-restore"
  fi

  echo ""
  if [[ $issues -eq 0 ]]; then
    info "All checks passed"
  else
    info "$issues issue(s) found"
  fi

  return $issues
}

# --- Subcommand: recover ---
cmd_recover() {
  local recovered=0

  info "Scanning for orphaned backups..."

  if compgen -G "$STATE_DIR/*.backup" >/dev/null 2>&1; then
    for backup in "$STATE_DIR"/*.backup; do
      [[ -f "$backup" ]] || continue

      # Metadata file holds original path (same prefix, .meta suffix)
      local meta_file="${backup%.backup}.meta"

      if [[ -f "$meta_file" ]]; then
        local original_path
        original_path="$(cat "$meta_file")"

        if [[ -n "$original_path" ]]; then
          info "Restoring: $original_path"
          cp -a "$backup" "$original_path" && rm -f "$backup" "$meta_file"
          recovered=$((recovered + 1))
        fi
      else
        echo "[??] Orphan without metadata: $backup"
        echo "     Cannot determine original location. Manual review needed."
      fi
    done
  fi

  if [[ $recovered -eq 0 ]]; then
    info "No backups to recover"
  else
    info "Recovered $recovered file(s)"
  fi
}

# --- Subcommand: which / explain ---
cmd_which() {
  local persona="$1"
  [[ -n "$persona" ]] || die "usage: agent-persona which <persona>"

  # Resolve persona (reuse resolution logic)
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" && root="$(pwd -P)"

  local PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

  local profile_type="" persona_src=""

  try_resolve_persona_dir() {
    local base="$1"
    if [[ -f "$base/$persona/AGENTS.md" ]]; then
      profile_type="file"; persona_src="$base/$persona/AGENTS.md"; return 0
    elif [[ -d "$base/$persona" ]]; then
      profile_type="dir"; persona_src="$base/$persona"; return 0
    fi
    return 1
  }

  _scan_repo_upwards() {
    local dir="$1"
    while true; do
      try_resolve_persona_dir "$dir/.personas" && return 0
      try_resolve_persona_dir "$dir/.persona" && return 0
      [[ "$dir" == "/" ]] && break
      dir="$(dirname -- "$dir")"
    done
    return 1
  }

  # Resolution
  if [[ "$PREFER_REPO" == "1" ]]; then
    _scan_repo_upwards "$root" || true
  fi
  if [[ -z "$persona_src" && -n "$EXTRA_PATHS" ]]; then
    IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
    for p in "${arr[@]:-}"; do
      [[ -n "$p" ]] && try_resolve_persona_dir "$p" && break
    done
  fi
  if [[ -z "$persona_src" ]]; then
    try_resolve_persona_dir "$HOME/.personas" || \
    try_resolve_persona_dir "$PERSONA_HOME/.personas" || \
    try_resolve_persona_dir "/usr/local/share/agent-persona/.personas" || true
  fi

  if [[ -z "$persona_src" ]]; then
    die "persona '$persona' not found"
  fi

  # Find repo meta
  local repo_root meta_path=""
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"
  if [[ "$META_ENABLED" != "0" ]]; then
    if [[ -n "$META_FILE_OVERRIDE" ]]; then
      meta_path="$META_FILE_OVERRIDE"
      [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
      if [[ -f "$meta_path" ]]; then
        meta_is_unedited_template "$meta_path" && meta_path=""
      else
        meta_path=""
      fi
    else
      for cand in ".personas/meta.AGENTS.md" ".personas/meta.agents.md" ".persona/meta.AGENTS.md" ".persona/meta.agents.md" "meta.AGENTS.md" "meta.agents.md"; do
        cand_path="$repo_root/$cand"
        if [[ -f "$cand_path" ]]; then
          if meta_is_unedited_template "$cand_path"; then
            log "skipping unedited meta template: $cand_path"
            continue
          fi
          meta_path="$cand_path"
          break
        fi
      done
    fi
  fi

  # Report
  echo "Persona:      $persona"
  echo "Source:       $persona_src"
  echo "Repo root:    $repo_root"
  echo "Meta file:    ${meta_path:-<none>}"
  echo "Meta enabled: $([[ "$META_ENABLED" == "0" ]] && echo "no" || echo "yes")"
  echo "Meta position: $META_POSITION"
  echo ""

  # Check overlay mechanism
  if [[ "$FORCE_SWAP" == "1" ]]; then
    echo "Overlay:      swap-and-restore (forced via --force-swap)"
  elif command -v unshare >/dev/null 2>&1 && unshare -Um true 2>/dev/null; then
    echo "Overlay:      bind-mount (via unshare, no on-disk change)"
  else
    echo "Overlay:      swap-and-restore (unshare unavailable)"
    echo "              NOTE: Small risk on hard-kill; use 'recover' if needed"
  fi
}

# --- Subcommand: print-overlay / --dry-run ---
cmd_print_overlay() {
  local tool="" persona=""

  # Parse arguments including flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-meta) META_ENABLED="0"; shift ;;
      --meta-position=*) META_POSITION="${1#*=}"; shift ;;
      --meta-position)
        shift
        [[ $# -gt 0 ]] || die "--meta-position requires a value"
        META_POSITION="$1"; shift
        ;;
      --meta-file=*) META_FILE_OVERRIDE="${1#*=}"; shift ;;
      --meta-file)
        shift
        [[ $# -gt 0 ]] || die "--meta-file requires a value"
        META_FILE_OVERRIDE="$1"; shift
        ;;
      -*)
        die "unknown flag: $1" ;;
      *)
        if [[ -z "$tool" ]]; then
          tool="$1"
        elif [[ -z "$persona" ]]; then
          persona="$1"
        fi
        shift
        ;;
    esac
  done

  tool="${tool:-codex}"
  [[ -n "$persona" ]] || die "usage: agent-persona print-overlay <tool> <persona>"

  # Determine overlay filename
  local overlay_name="AGENTS.md"
  case "$tool" in
    claude|claude-code) overlay_name="CLAUDE.md" ;;
    gemini) overlay_name="GEMINI.md" ;;
  esac

  # Resolve persona
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" && root="$(pwd -P)"

  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local persona_dir=""

  # Find persona directory
  for base in "$root/.personas" "$root/.persona" "$HOME/.personas" "$PERSONA_HOME/.personas" "/usr/local/share/agent-persona/.personas"; do
    if [[ -d "$base/$persona" && -f "$base/$persona/AGENTS.md" ]]; then
      persona_dir="$base/$persona"
      break
    fi
  done

  [[ -n "$persona_dir" ]] || die "persona '$persona' not found"

  # Resolve instruction file (tool-specific or fallback to AGENTS.md)
  local persona_src
  persona_src="$(resolve_instruction_file "$persona_dir" "$overlay_name")"
  [[ -f "$persona_src" ]] || die "instruction file not found: $persona_src"

  # Find and merge meta
  local repo_root meta_path=""
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"

  if [[ "$META_ENABLED" != "0" ]]; then
    if [[ -n "$META_FILE_OVERRIDE" ]]; then
      meta_path="$META_FILE_OVERRIDE"
      [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
      if [[ -f "$meta_path" ]]; then
        meta_is_unedited_template "$meta_path" && meta_path=""
      else
        meta_path=""
      fi
    else
      for cand in ".personas/meta.AGENTS.md" ".personas/meta.agents.md" ".persona/meta.AGENTS.md" ".persona/meta.agents.md" "meta.AGENTS.md" "meta.agents.md"; do
        cand_path="$repo_root/$cand"
        if [[ -f "$cand_path" ]]; then
          if meta_is_unedited_template "$cand_path"; then
            log "skipping unedited meta template: $cand_path"
            continue
          fi
          meta_path="$cand_path"
          break
        fi
      done
    fi
  fi

  # Determine which instruction file type is being used
  local instruction_type="default"
  [[ "$persona_src" == *"/$overlay_name" && "$overlay_name" != "AGENTS.md" ]] && instruction_type="tool-specific"

  echo "# === COMPOSED OVERLAY: $overlay_name ==="
  echo "# Persona dir: $persona_dir"
  echo "# Instruction: $persona_src ($instruction_type)"
  [[ -n "$meta_path" ]] && echo "# Meta: $meta_path (position: $META_POSITION)"
  echo ""

  if [[ -n "$meta_path" && "$META_POSITION" == "top" ]]; then
    echo "<!-- meta -->"
    cat "$meta_path"
    echo ""
    echo "<!-- /meta -->"
    echo ""
  fi

  echo "<!-- persona -->"
  cat "$persona_src"
  echo ""
  echo "<!-- /persona -->"

  if [[ -n "$meta_path" && "$META_POSITION" == "bottom" ]]; then
    echo ""
    echo "<!-- meta -->"
    cat "$meta_path"
    echo ""
    echo "<!-- /meta -->"
  fi
}

# --- Subcommand: list ---
cmd_list() {
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" 2>/dev/null || die "unable to cd to root: $root"
  root="$(pwd -P)"

  local PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

  local found=0

  _list_from_base() {
    local base="$1" label="$2" d slug
    [[ -d "$base" ]] || return 0
    for d in "$base"/*; do
      [[ -d "$d" && -f "$d/AGENTS.md" ]] || continue
      slug="$(basename -- "$d")"
      printf '%s\t%s\t%s\n' "$slug" "$label" "$d"
      found=1
    done
  }

  printf 'PERSONA\tSOURCE\tPATH\n'

  _list_repo_upwards() {
    local dir="$1"
    while true; do
      _list_from_base "$dir/.personas" repo
      _list_from_base "$dir/.persona" repo
      [[ "$dir" == "/" ]] && break
      dir="$(dirname -- "$dir")"
    done
  }

  if [[ "$PREFER_REPO" == "1" ]]; then
    _list_repo_upwards "$root"
  fi

  if [[ -n "$EXTRA_PATHS" ]]; then
    IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
    for p in "${arr[@]:-}"; do [[ -n "$p" ]] && _list_from_base "$p" paths; done
  fi

  _list_from_base "$HOME/.personas" home
  _list_from_base "$PERSONA_HOME/.personas" user
  _list_from_base "/usr/local/share/agent-persona/.personas" system

  if [[ $found -eq 0 ]]; then
    echo "(no personas found)" >&2
    exit 1
  fi
}

# --- Usage ---
usage() {
  cat >&2 <<USAGE
agent-persona v$VERSION — tool-agnostic persona launcher for AI coding agents

USAGE:
  agent-persona <tool> <persona> [--] [tool args...]
  agent-persona init [path]           Scaffold .personas/ in a repo
  agent-persona doctor                Verify installation and state
  agent-persona recover               Restore files after hard-kill
  agent-persona which <persona>       Show resolved paths (no launch)
  agent-persona print-overlay <t> <p> Show composed overlay (dry-run)
  agent-persona --list                List available personas

TOOLS:
  codex, claude, claude-code, gemini, opencode
  Or any executable on PATH

FLAGS:
  --no-meta                 Skip repo meta.AGENTS.md merge
  --no-mcp                  Skip MCP injection from persona.json
  --meta-file=<path>        Override meta file path
  --meta-position=top|bottom  Where to merge meta (default: top)
  --force-swap              Force swap-and-restore (skip unshare)
  --strict-policy           Fail if policy cannot be enforced
  --version                 Show version
  -h, --help                Show this help

ENVIRONMENT:
  AGENT_PERSONA_DEBUG=1             Enable debug logging
  AGENT_PERSONA_META=0              Disable meta merge
  AGENT_PERSONA_META_FILE=<path>    Override meta file
  AGENT_PERSONA_META_POSITION=...   top or bottom
  AGENT_PERSONA_FORCE_SWAP=1        Force swap mode
  AGENT_PERSONA_MCP=0               Disable MCP injection
  AGENT_PERSONA_STRICT_POLICY=1     Fail if policy cannot be enforced
  AGENT_PERSONA_PATHS=<p1:p2:...>   Extra search paths
  AGENT_PERSONA_HOME=<path>         Persona home (contains .personas/)

EXPORTED TO TOOL (v1.1+):
  AGENT_PERSONA_NAME          Persona slug (e.g., "code-reviewer")
  AGENT_PERSONA_PATH          Resolved persona directory path
  AGENT_PERSONA_TOOL          Tool being launched (claude, codex, etc.)
  AGENT_PERSONA_OVERLAY_FILE  Target overlay file (CLAUDE.md, AGENTS.md, etc.)
  AGENT_PERSONA_RUN_MODE      Launch mode (unshare or swap)

OVERLAY BEHAVIOR:
  Linux with unprivileged user namespaces:
    Uses bind-mount via unshare. No on-disk changes.

  Otherwise (or with --force-swap):
    Swap-and-restore: backs up existing file, copies persona,
    restores on exit. Small risk on hard-kill (SIGKILL/crash).
    Use 'agent-persona recover' to restore after hard-kill.

REPO META:
  If .personas/meta.AGENTS.md matches the init template, it is ignored until you edit it.

EXAMPLES:
  agent-persona claude blank          # Launch Claude with blank persona
  agent-persona codex my-agent        # Launch Codex with my-agent persona
  agent-persona init                  # Setup .personas/ in current repo
  agent-persona which my-agent        # Check where persona resolves from
USAGE
}

# --- Main argument parsing ---
invoked="$(basename -- "$0")"
tool=""
case "$invoked" in
  codex-persona) tool="codex";;
  opencode-persona) tool="opencode";;
  claude-persona) tool="claude";;
  gemini-persona) tool="gemini";;
esac

persona=""
pass_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    # Subcommands
    init)
      shift; cmd_init "$@"; exit $?
      ;;
    doctor)
      cmd_doctor; exit $?
      ;;
    recover)
      cmd_recover; exit $?
      ;;
    which|explain)
      shift
      cmd_which "$@"; exit $?
      ;;
    print-overlay|--dry-run)
      shift
      cmd_print_overlay "$@"; exit $?
      ;;

    # Flags
    -l|--list)
      cmd_list; exit $?
      ;;
    --version|-V)
      echo "agent-persona $VERSION"
      exit 0
      ;;
    -h|--help)
      usage; exit 0
      ;;
    --no-meta)
      META_ENABLED="0"; shift
      ;;
    --no-mcp)
      MCP_ENABLED="0"; shift
      ;;
    --meta-file=*)
      META_FILE_OVERRIDE="${1#*=}"; shift
      ;;
    --meta-file)
      shift
      [[ $# -gt 0 ]] || die "--meta-file requires a value"
      META_FILE_OVERRIDE="$1"; shift
      ;;
    --meta-position=*)
      META_POSITION="${1#*=}"; shift
      ;;
    --meta-position)
      shift
      [[ $# -gt 0 ]] || die "--meta-position requires a value"
      META_POSITION="$1"; shift
      ;;
    --force-swap|--no-unshare)
      FORCE_SWAP="1"; shift
      ;;
    --strict-policy)
      STRICT_POLICY="1"; shift
      ;;
    --tool)
      shift; [[ $# -gt 0 ]] || die "--tool requires a value"
      tool="$1"; shift
      ;;
    --tool=*)
      tool="${1#*=}"; shift
      ;;
    --)
      shift; pass_args=("$@"); break
      ;;
    -*)
      # Unknown flag - pass through to tool
      pass_args+=("$1"); shift
      ;;
    *)
      # Positional: tool (if not set), then persona, then pass-through
      if [[ -z "$tool" ]]; then
        cand="$1"
        if command -v "$cand" >/dev/null 2>&1 || [[ "$cand" =~ ^(codex|opencode|claude|claude-code|gemini)$ ]]; then
          tool="$cand"; shift; continue
        fi
      fi
      if [[ -z "$persona" ]]; then
        persona="$1"; shift
      else
        pass_args+=("$1"); shift
      fi
      ;;
  esac
done

# Validate
[[ -n "$persona" ]] || { usage; exit 2; }
[[ -n "$tool" ]] || die "tool required. Use: agent-persona <tool> <persona>"

# --- Resolve working root ---
root="${AGENT_PERSONA_ROOT:-$(pwd)}"
cd "$root"
root="$(pwd -P)"

# --- Resolve persona ---
PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

profile_type=""
persona_src=""

try_resolve_persona_dir() {
  local base="$1"
  if [[ -f "$base/$persona/AGENTS.md" ]]; then
    profile_type="file"; persona_src="$base/$persona/AGENTS.md"; return 0
  elif [[ -d "$base/$persona" && -f "$base/$persona/AGENTS.md" ]]; then
    profile_type="dir"; persona_src="$base/$persona"; return 0
  fi
  return 1
}

_scan_repo_upwards() {
  local dir="$1"
  while true; do
    try_resolve_persona_dir "$dir/.personas" && return 0
    try_resolve_persona_dir "$dir/.persona" && return 0
    [[ "$dir" == "/" ]] && break
    dir="$(dirname -- "$dir")"
  done
  return 1
}

# Resolution order
if [[ "$PREFER_REPO" == "1" ]]; then
  _scan_repo_upwards "$root" || true
fi

if [[ -z "$persona_src" && -n "$EXTRA_PATHS" ]]; then
  IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
  for p in "${arr[@]:-}"; do
    [[ -n "$p" ]] && try_resolve_persona_dir "$p" && break
  done
fi

if [[ -z "$persona_src" ]]; then
  try_resolve_persona_dir "$HOME/.personas" || \
  try_resolve_persona_dir "$PERSONA_HOME/.personas" || \
  try_resolve_persona_dir "/usr/local/share/agent-persona/.personas" || true
fi

if [[ -z "$persona_src" && "$PREFER_REPO" != "1" ]]; then
  _scan_repo_upwards "$root" || true
fi

[[ -n "$persona_src" ]] || die "persona '$persona' not found"

log "persona source: $persona_src"

# --- Normalize persona directory (handles file-vs-dir profiles) ---
persona_dir="$(get_persona_dir "$persona_src" "$profile_type")"

# --- Determine overlay filename (moved earlier for per-tool instruction support) ---
overlay_name="AGENTS.md"
case "$tool" in
  claude|claude-code) overlay_name="CLAUDE.md" ;;
  gemini) overlay_name="GEMINI.md" ;;
esac

# --- Resolve instruction file (tool-specific or fallback to AGENTS.md) ---
link_target="$(resolve_instruction_file "$persona_dir" "$overlay_name")"
[[ -f "$link_target" ]] || die "persona instructions not found: $link_target"
log "instruction file: $link_target"

# --- Export persona metadata for tracing/logging/memory ---
export AGENT_PERSONA_NAME="$persona"
export AGENT_PERSONA_PATH="$persona_dir"
export AGENT_PERSONA_TOOL="$tool"
export AGENT_PERSONA_OVERLAY_FILE="$overlay_name"
# AGENT_PERSONA_RUN_MODE is set just before each launch path

# --- Load per-tool defaults from persona.json ---
json_cfg=""
base_dir="$persona_dir"
for cand in "$base_dir/persona.json" "$base_dir/Persona.json" "$base_dir/config.json"; do
  [[ -f "$cand" ]] && { json_cfg="$cand"; break; }
done

defaults=()
if [[ -n "$json_cfg" ]]; then
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    defaults+=( "$line" )
  done < <(defaults_from_json "$json_cfg" "$tool")
fi

# --- Detect policy in persona.json ---
has_policy=0
if [[ -n "$json_cfg" ]] && policy_exists_in_json "$json_cfg"; then
  has_policy=1
  log "policy detected in persona.json"

  # Policy requires Python for translation
  if ! command -v python3 >/dev/null 2>&1 && ! command -v python >/dev/null 2>&1; then
    die "policy defined in persona.json but Python not available (required for enforcement)"
  fi
fi

# --- Tool-specific defaults (suppressed when policy exists) ---
tool_cmd="$tool"
case "$tool" in
  claude|claude-code)
    if command -v claude >/dev/null 2>&1; then
      tool_cmd="claude"
    elif command -v claude-code >/dev/null 2>&1; then
      tool_cmd="claude-code"
    fi
    # Default permission mode (skip if policy exists - policy controls permissions)
    if [[ $has_policy -eq 0 ]]; then
      has_perm=0
      for a in "${pass_args[@]}" "${defaults[@]}"; do
        [[ "$a" == "--permission-mode"* || "$a" == "--dangerously-skip-permissions" ]] && has_perm=1
      done
      [[ $has_perm -eq 0 ]] && defaults+=(--permission-mode bypassPermissions)
    else
      log "policy present, skipping default --permission-mode bypassPermissions"
    fi
    ;;
  codex)
    # Default to --full-auto unless already specified (skip if policy exists)
    if [[ $has_policy -eq 0 ]]; then
      has_auto=0
      for a in "${pass_args[@]}" "${defaults[@]}"; do
        [[ "$a" == "--full-auto" || "$a" == "--yolo" || "$a" == "--dangerously-bypass-approvals-and-sandbox" ]] && has_auto=1
      done
      [[ $has_auto -eq 0 ]] && defaults+=(--full-auto)
    else
      log "policy present, skipping default --full-auto"
    fi
    ;;
esac

# --- MCP servers (persona.json) ---
if [[ "$MCP_ENABLED" != "0" && -n "$json_cfg" && "$tool" == "codex" ]]; then
  while IFS= read -r ov; do
    [[ -n "$ov" ]] || continue
    defaults+=( -c "$ov" )
  done < <(codex_mcp_overrides_from_json "$json_cfg")
fi

if [[ "$MCP_ENABLED" != "0" && -n "$json_cfg" && ( "$tool" == "claude" || "$tool" == "claude-code" ) ]]; then
  have_mcp_config=0
  for a in "${pass_args[@]}" "${defaults[@]}"; do
    [[ "$a" == "--mcp-config" || "$a" == --mcp-config=* ]] && have_mcp_config=1
  done
  if [[ $have_mcp_config -eq 0 ]]; then
    mcp_config_file="$(extract_mcp_config "$json_cfg")" || mcp_config_file=""
    if [[ -n "$mcp_config_file" && -f "$mcp_config_file" ]]; then
      log "MCP config extracted to: $mcp_config_file"
      defaults+=( --mcp-config "$mcp_config_file" )
    fi
  fi
fi

# --- Policy translation (populate policy_args for enforcement) ---
policy_args=()
if [[ $has_policy -eq 1 && -n "$json_cfg" ]]; then
  log "translating policy for tool: $tool"

  case "$tool" in
    claude|claude-code)
      # tools.allow -> --tools (comma-separated)
      mapfile -t allowed_tools < <(policy_tools_allow "$json_cfg" "claude")
      if (( ${#allowed_tools[@]} > 0 )); then
        allowed_csv=$(IFS=','; echo "${allowed_tools[*]}")
        policy_args+=(--tools "$allowed_csv")
        log "policy: --tools $allowed_csv"
      fi

      # tools.deny -> --disallowedTools
      mapfile -t denied_tools < <(policy_tools_deny "$json_cfg" "claude")
      if (( ${#denied_tools[@]} > 0 )); then
        policy_args+=(--disallowedTools "${denied_tools[@]}")
        log "policy: --disallowedTools ${denied_tools[*]}"
      fi

      # paths.deny -> --settings (temp JSON file)
      claude_settings_file="$(generate_claude_settings "$json_cfg")" || claude_settings_file=""
      if [[ -n "$claude_settings_file" && -f "$claude_settings_file" ]]; then
        policy_args+=(--settings "$claude_settings_file")
        log "policy: --settings $claude_settings_file"
      fi
      ;;

    codex)
      # Generate sandbox overrides
      while IFS= read -r ov; do
        [[ -n "$ov" ]] || continue
        policy_args+=(-c "$ov")
        log "policy: -c $ov"
      done < <(codex_policy_overrides "$json_cfg" "$root")
      ;;

    gemini)
      # Generate settings file and set env var
      gemini_settings_file="$(generate_gemini_settings "$json_cfg")" || gemini_settings_file=""
      if [[ -n "$gemini_settings_file" && -f "$gemini_settings_file" ]]; then
        export GEMINI_CLI_SYSTEM_SETTINGS_PATH="$gemini_settings_file"
        log "policy: GEMINI_CLI_SYSTEM_SETTINGS_PATH=$gemini_settings_file"
      fi
      ;;

    opencode)
      # Generate config file and set env var
      opencode_config_file="$(generate_opencode_config "$json_cfg")" || opencode_config_file=""
      if [[ -n "$opencode_config_file" && -f "$opencode_config_file" ]]; then
        export OPENCODE_CONFIG="$opencode_config_file"
        log "policy: OPENCODE_CONFIG=$opencode_config_file"
      fi
      ;;

    *)
      # Unknown tool - warn if policy exists
      warn "policy defined but tool '$tool' does not have policy translation support"
      ;;
  esac
fi

# --- Merge repo meta if present ---
meta_files=()
if [[ "$META_ENABLED" != "0" ]]; then
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"

  if [[ -n "$META_FILE_OVERRIDE" ]]; then
    meta_path="$META_FILE_OVERRIDE"
    [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
    if [[ -f "$meta_path" ]]; then
      if meta_is_unedited_template "$meta_path"; then
        log "skipping unedited meta template: $meta_path"
      else
        meta_files+=("$meta_path")
      fi
    fi
  else
    for cand in ".personas/meta.AGENTS.md" ".personas/meta.agents.md" ".persona/meta.AGENTS.md" ".persona/meta.agents.md" "meta.AGENTS.md" "meta.agents.md"; do
      cand_path="$repo_root/$cand"
      if [[ -f "$cand_path" ]]; then
        if meta_is_unedited_template "$cand_path"; then
          log "skipping unedited meta template: $cand_path"
          continue
        fi
        meta_files+=("$cand_path")
        break
      fi
    done
  fi
fi

if (( ${#meta_files[@]} > 0 )); then
  meta_tmp="$(mktemp -p "${TMPDIR:-/tmp}" "agent-persona.${overlay_name}.XXXXXX")"

  case "$META_POSITION" in
    top|prepend|before)
      {
        for p in "${meta_files[@]}"; do
          echo "<!-- meta -->"
          cat "$p"
          echo -e "\n<!-- /meta -->\n"
        done
        echo "<!-- persona -->"
        cat "$link_target"
        echo -e "\n<!-- /persona -->"
      } > "$meta_tmp"
      ;;
    bottom|append|after)
      {
        echo "<!-- persona -->"
        cat "$link_target"
        echo -e "\n<!-- /persona -->\n"
        for p in "${meta_files[@]}"; do
          echo "<!-- meta -->"
          cat "$p"
          echo -e "\n<!-- /meta -->"
        done
      } > "$meta_tmp"
      ;;
    *)
      die "invalid meta position: $META_POSITION (expected: top|bottom)"
      ;;
  esac

  link_target="$meta_tmp"
  log "meta merged ($META_POSITION): ${meta_files[*]}"
fi

# --- Build final args (3-way layering for policy enforcement) ---
# Layer 1: default_args (persona defaults from persona.json)
# Layer 2: filtered_user_args (pass-through with policy-controlled flags removed)
# Layer 3: policy_args (enforcement - populated by policy translation above)

default_args=("${defaults[@]}")
# policy_args already populated by policy translation section above

# Filter user args if policy exists
filtered_user_args=()
if [[ $has_policy -eq 1 ]]; then
  mapfile -d '' filtered_user_args < <(filter_user_args "$tool" "$has_policy" "${pass_args[@]}")
else
  filtered_user_args=("${pass_args[@]}")
fi

# Final assembly: defaults + filtered_user + policy (policy wins on conflicts)
tool_args=("${default_args[@]}" "${filtered_user_args[@]}" "${policy_args[@]}")

quote_join() {
  local out="" q
  for x in "$@"; do printf -v q '%q' "$x"; out+="$q "; done
  printf '%s' "$out"
}

# --- Strategy 1: bind-mount via unshare (preferred) ---
launch_ok=0
args_quoted="$(quote_join "${tool_args[@]}")"

if [[ "$FORCE_SWAP" != "1" ]] && command -v unshare >/dev/null 2>&1; then
  export AGENT_PERSONA_RUN_MODE="unshare"
  set +e
  tmp_err="$(mktemp)"
  unshare -Um bash -lc "set -euo pipefail
    root_dir=$(printf '%q' "$root")
    persona_file=$(printf '%q' "$link_target")
    agents_path=$(printf '%q' "$root/$overlay_name")

    created=0
    if [[ ! -e \"\$agents_path\" ]]; then
      touch \"\$agents_path\"
      created=1
    fi

    cleanup() {
      umount \"\$agents_path\" 2>/dev/null || true
      [[ \$created -eq 1 ]] && rm -f \"\$agents_path\"
    }
    trap cleanup EXIT INT TERM

    mount --bind \"\$persona_file\" \"\$agents_path\"
    cd \"\$root_dir\"

    if command -v $(printf '%q' "$tool_cmd") >/dev/null 2>&1; then
      $(printf '%q' "$tool_cmd") $args_quoted
    else
      echo 'tool not found: $tool_cmd' >&2
      exit 127
    fi
  " 2>"$tmp_err"
  rc=$?
  set -e

  if [[ $rc -eq 0 ]]; then
    launch_ok=1
  else
    log "unshare failed (rc=$rc): $(<"$tmp_err")"
  fi
  rm -f "$tmp_err" 2>/dev/null || true
fi

# --- Strategy 2: swap-and-restore (fallback) ---
if [[ $launch_ok -eq 0 ]]; then
  export AGENT_PERSONA_RUN_MODE="swap"
  log "using swap-and-restore mode"

  swap_prev_kind="none"
  swap_prev_target=""
  swap_prev_backup=""
  swap_backup_meta=""
  swap_overlay_path="$root/$overlay_name"

  # Save current state
  if [[ -L "$swap_overlay_path" ]]; then
    swap_prev_kind="symlink"
    swap_prev_target="$(readlink "$swap_overlay_path" || true)"
  elif [[ -f "$swap_overlay_path" ]]; then
    swap_prev_kind="file"
    swap_prev_backup="$(mktemp -p "$STATE_DIR" "agent-persona.${overlay_name}.XXXXXX.backup")"
    swap_backup_meta="${swap_prev_backup%.backup}.meta"
    cp -a "$swap_overlay_path" "$swap_prev_backup"
    echo "$swap_overlay_path" > "$swap_backup_meta"
  fi

  swap_active=1
  swap_restored=0

  # Copy persona to overlay location
  if ! cp -a --remove-destination "$link_target" "$swap_overlay_path" 2>/dev/null; then
    rm -f "$swap_overlay_path" 2>/dev/null || true
    cp -a "$link_target" "$swap_overlay_path" || die "failed to copy persona"
  fi

  cd "$root"
  if command -v "$tool_cmd" >/dev/null 2>&1; then
    "$tool_cmd" "${tool_args[@]}"
    launch_ok=1
  else
    die "tool not found: $tool_cmd"
  fi

  swap_restore
fi

[[ $launch_ok -eq 1 ]] || die "failed to launch"
