#!/usr/bin/env bash
# shellcheck disable=SC2015
set -euo pipefail

# agent-persona â€” tool-agnostic persona launcher for AI coding agents
# https://github.com/GoodFarming/agent-persona
#
# Usage:
#   agent-persona <tool> <persona> [--] [tool args...]
#   agent-persona init              # scaffold .personas/ in current repo
#   agent-persona doctor            # verify install, check for orphaned state
#   agent-persona recover           # restore AGENTS.md from backup after hard-kill
#   agent-persona which <persona>   # show resolved paths without launching
#   agent-persona --list            # list available personas
#   agent-persona --version         # show version
#
# Tool-specific shims:
#   codex-persona <persona>         # launches codex
#   claude-persona <persona>        # launches claude (overlays CLAUDE.md)
#   gemini-persona <persona>        # launches gemini (overlays GEMINI.md)
#
# Overlay behavior (Linux):
#   - With unshare: bind-mount overlay (no on-disk change)
#   - Without unshare: swap-and-restore (small risk on hard-kill; use 'recover')

VERSION="1.1.0"

DEBUG_FLAG="${AGENT_PERSONA_DEBUG:-}"
log() { [[ -n "$DEBUG_FLAG" ]] && echo "[agent-persona] $*" >&2 || true; }
die() { echo "[agent-persona] error: $*" >&2; exit 1; }
warn() { echo "[agent-persona] warning: $*" >&2; }
info() { echo "[agent-persona] $*" >&2; }

# --- Configuration (env vars with CLI flag overrides) ---
UPDATE_CHECK="${AGENT_PERSONA_UPDATE_CHECK:-1}"
UPDATE_CHECK_INTERVAL="${AGENT_PERSONA_UPDATE_CHECK_INTERVAL:-86400}"  # 24 hours

META_ENABLED="${AGENT_PERSONA_META:-1}"
META_FILE_OVERRIDE="${AGENT_PERSONA_META_FILE:-}"
META_POSITION="${AGENT_PERSONA_META_POSITION:-top}"
FORCE_SWAP="${AGENT_PERSONA_FORCE_SWAP:-0}"
MCP_ENABLED="${AGENT_PERSONA_MCP:-1}"
DEFAULTS_ENABLED="${AGENT_PERSONA_DEFAULTS:-1}"
INCLUDE_DEPTH="${AGENT_PERSONA_INCLUDE_DEPTH:-10}"
GEMINI_FORCE_TTY="${AGENT_PERSONA_GEMINI_FORCE_TTY:-auto}"

meta_tmp=""
cleanup_meta() { [[ -n "${meta_tmp:-}" ]] && rm -f "$meta_tmp" 2>/dev/null || true; }

include_tmp_files=()
cleanup_includes() {
  local f
  for f in "${include_tmp_files[@]:-}"; do
    [[ -n "$f" ]] && rm -f "$f" 2>/dev/null || true
  done
}

default_meta_template() {
  cat <<'META'
# Repo-Wide Agent Instructions

These instructions are automatically merged into every persona launched in this repository.
Edit this file to add project-specific context for your agents.

## Project Context
<!-- Describe your project so agents understand the codebase -->
This is [PROJECT NAME], a [brief description].

**Tech stack:**
- Language: [e.g., TypeScript, Python, Go]
- Framework: [e.g., React, FastAPI, Echo]
- Database: [e.g., PostgreSQL, SQLite, none]

**Key directories:**
- `src/` - Main source code
- `tests/` - Test files
- `docs/` - Documentation

## Conventions
<!-- Coding standards and patterns used in this project -->
- Use [style guide or formatter, e.g., Prettier, Black]
- Follow [naming convention, e.g., camelCase for functions]
- Write tests for new functionality
- Keep commits atomic and well-described

## Do Not
<!-- Things agents should avoid in this repo -->
- Modify files in `vendor/` or `node_modules/`
- Change configuration without discussing first
- Skip tests when making changes

## Notes
<!-- Any other context that helps agents work effectively -->
- The main branch is `main`, PRs required for all changes
- CI runs on every push; check status before marking done
META
}

meta_is_unedited_template() {
  local meta_path="$1"
  [[ -f "$meta_path" ]] || return 1
  # Treat the init-generated meta template as "no meta" until the user edits it.
  local file_content template_content
  file_content="$(tr -d '\r' < "$meta_path" | sed -e 's/[ \t]*$//' )"
  template_content="$(default_meta_template | tr -d '\r' | sed -e 's/[ \t]*$//' )"
  [[ "$file_content" == "$template_content" ]]
}

default_readme_template() {
  cat <<'README'
# Repo-local personas (`.personas/`)

This repository is set up for repo-local agent personas via `agent-persona`.

## Repo-wide instructions (meta)

- `.personas/.shared/meta.AGENTS.md` is merged into every persona launched in this repo.
- The default template created by `agent-persona init` is ignored until you edit it.
- Disable meta merge: `agent-persona ... --no-meta` or `AGENT_PERSONA_META=0`
- Merge position: `--meta-position top|bottom` (default: top)

## Shared blocks

- Reusable instruction blocks live under `.personas/.shared/`.
- Include them from any AGENTS/CLAUDE/GEMINI file:

```md
<!-- include {"file":"communication-discipline.md"} -->
```

## Template variables

- Use `{{persona}}` in shared blocks or meta files to reference the current persona name.
- Example: `.persona/{{persona}}/PLAN.md` expands to `.persona/my-agent/PLAN.md`

## Add a persona

Create a folder and an `AGENTS.md`:

```bash
mkdir -p .personas/my-persona
$EDITOR .personas/my-persona/AGENTS.md
```

Optional `persona.json` (defaults + MCP):

```json
{
  "defaults": {
    "codex": ["--full-auto"],
    "claude": ["--permission-mode", "bypassPermissions"]
  },
  "mcpServers": {
    "myserver": {
      "command": "my-mcp-server",
      "args": ["--flag"],
      "env": { "MY_ENV": "value" }
    }
  }
}
```

## Launch

```bash
agent-persona codex my-persona
agent-persona claude my-persona
agent-persona gemini my-persona
```

## Notes

- On Linux, `agent-persona` prefers a bind-mount overlay via `unshare` (no on-disk changes).
- If `unshare` isn't available, it falls back to swap-and-restore. If you hard-kill the tool, run `agent-persona recover`.
README
}

# Ensure README.md exists in the repo's persona directory
ensure_persona_dir_readme() {
  local persona_dir="$1"
  local parent_dir readme_path
  parent_dir="$(dirname "$persona_dir")"
  local parent_name
  parent_name="$(basename "$parent_dir")"

  # Only inject README for repo .persona/.personas directories (not user/system)
  if [[ "$parent_name" == ".persona" || "$parent_name" == ".personas" ]]; then
    # Skip if this is under $HOME/.local, $HOME/.personas, or system paths
    case "$parent_dir" in
      "$HOME/.local"*|"$HOME/.personas"*|"/usr/local/share"*|"/usr/share"*)
        return 0
        ;;
    esac
    readme_path="$parent_dir/README.md"
    if [[ ! -f "$readme_path" ]]; then
      default_readme_template > "$readme_path"
      log "created $readme_path"
    fi
  fi
}

# --- Update checking ---
version_gt() {
  # Returns 0 if $1 > $2 (semver comparison)
  [[ "$1" == "$2" ]] && return 1
  local IFS=.
  local i v1=($1) v2=($2)
  for ((i=0; i<${#v1[@]} || i<${#v2[@]}; i++)); do
    local n1="${v1[i]:-0}" n2="${v2[i]:-0}"
    ((n1 > n2)) && return 0
    ((n1 < n2)) && return 1
  done
  return 1
}

check_for_updates() {
  [[ "$UPDATE_CHECK" == "0" ]] && return 0
  command -v curl >/dev/null 2>&1 || return 0

  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/agent-persona"
  local cache_file="$cache_dir/latest-version"
  local now cached_time cached_version
  now="$(date +%s)"

  # Check cache first
  if [[ -f "$cache_file" ]]; then
    read -r cached_time cached_version < "$cache_file" 2>/dev/null || true
    if [[ -n "$cached_time" && -n "$cached_version" ]]; then
      if (( now - cached_time < UPDATE_CHECK_INTERVAL )); then
        # Cache is fresh - compare versions
        if version_gt "$cached_version" "$VERSION"; then
          echo "[agent-persona] Update available: $cached_version (current: $VERSION). Run: git -C \"${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}\" pull" >&2
        fi
        return 0
      fi
    fi
  fi

  # Fetch latest version in background (don't block startup)
  (
    local latest_version
    latest_version="$(curl -sf --max-time 3 \
      "https://raw.githubusercontent.com/GoodFarming/agent-persona/main/agent-persona" 2>/dev/null \
      | grep -m1 '^VERSION=' | sed 's/VERSION="\([^"]*\)"/\1/')" || true

    if [[ -n "$latest_version" ]]; then
      mkdir -p "$cache_dir" 2>/dev/null
      echo "$now $latest_version" > "$cache_file" 2>/dev/null
      if version_gt "$latest_version" "$VERSION"; then
        echo "[agent-persona] Update available: $latest_version (current: $VERSION). Run: git -C \"${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}\" pull" >&2
      fi
    fi
  ) &
}

# --- MCP temp config (Claude) ---
mcp_config_file=""
cleanup_mcp() { [[ -n "${mcp_config_file:-}" && -f "$mcp_config_file" ]] && rm -f "$mcp_config_file" 2>/dev/null || true; }

# --- Policy temp config files ---
claude_settings_file=""
gemini_settings_file=""
opencode_config_file=""
gemini_wrapper_file=""
cleanup_policy() {
  [[ -n "${claude_settings_file:-}" && -f "$claude_settings_file" ]] && rm -f "$claude_settings_file" 2>/dev/null || true
  [[ -n "${gemini_settings_file:-}" && -f "$gemini_settings_file" ]] && rm -f "$gemini_settings_file" 2>/dev/null || true
  [[ -n "${opencode_config_file:-}" && -f "$opencode_config_file" ]] && rm -f "$opencode_config_file" 2>/dev/null || true
}
cleanup_gemini() { [[ -n "${gemini_wrapper_file:-}" && -f "$gemini_wrapper_file" ]] && rm -f "$gemini_wrapper_file" 2>/dev/null || true; }

# --- Policy configuration ---
STRICT_POLICY="${AGENT_PERSONA_STRICT_POLICY:-0}"

# --- Swap-and-restore state (fallback when unshare unavailable) ---
swap_active=0
swap_restored=0
swap_prev_kind="none"   # none|file|symlink
swap_prev_target=""
swap_prev_backup=""
swap_backup_meta=""
swap_overlay_path=""

swap_restore() {
  [[ "${swap_active:-0}" == "1" ]] || return 0
  [[ "${swap_restored:-0}" == "0" ]] || return 0
  swap_restored=1

  case "${swap_prev_kind:-none}" in
    symlink)
      [[ -n "${swap_prev_target:-}" && -n "${swap_overlay_path:-}" ]] && \
        ln -sfn "$swap_prev_target" "$swap_overlay_path" 2>/dev/null || true
      ;;
    file)
      if [[ -n "${swap_prev_backup:-}" && -f "$swap_prev_backup" && -n "${swap_overlay_path:-}" ]]; then
        if cp -a --remove-destination "$swap_prev_backup" "$swap_overlay_path" 2>/dev/null; then
          rm -f "$swap_prev_backup" "${swap_backup_meta:-}" 2>/dev/null || true
        elif { rm -f "$swap_overlay_path" 2>/dev/null || true; cp -a "$swap_prev_backup" "$swap_overlay_path" 2>/dev/null; }; then
          rm -f "$swap_prev_backup" "${swap_backup_meta:-}" 2>/dev/null || true
        fi
      fi
      ;;
    none)
      [[ -n "${swap_overlay_path:-}" ]] && rm -f "$swap_overlay_path" 2>/dev/null || true
      ;;
  esac

  swap_active=0
}

cleanup_session() {
  set +e
  swap_restore
  cleanup_meta
  cleanup_includes
  cleanup_mcp
  cleanup_policy
  cleanup_gemini
}
trap cleanup_session EXIT INT TERM

# --- Backup/recovery state directory ---
STATE_DIR="${AGENT_PERSONA_STATE_DIR:-${TMPDIR:-/tmp}/agent-persona-state}"
mkdir -p "$STATE_DIR" 2>/dev/null || true

resolve_repo_root() {
  local dir="${1:-$(pwd)}"
  # Convert to absolute path to avoid infinite loop with relative paths
  dir="$(cd "$dir" 2>/dev/null && pwd -P)" || return 1

  if command -v git >/dev/null 2>&1; then
    local git_root
    git_root="$(cd "$dir" && git rev-parse --show-toplevel 2>/dev/null || true)"
    [[ -n "$git_root" ]] && { echo "$git_root"; return 0; }
  fi
  while true; do
    if [[ -d "$dir/.git" || -f "$dir/.git" ]]; then echo "$dir"; return 0; fi
    [[ "$dir" == "/" ]] && break
    dir="$(dirname -- "$dir")"
  done
  return 1
}

# --- persona.json helpers ---
defaults_from_json() {
  local json_path="$1"; local tool_key="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_key" <<'PY' || true
import json, sys
path, tool = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

defaults = []
if isinstance(j.get("defaults"), dict):
    d = j["defaults"]
    # Global defaults (synonyms): global, *, any (first match wins)
    for k in ("global", "*", "any"):
        v = d.get(k)
        if isinstance(v, list):
            defaults.extend([x for x in v if isinstance(x, str)])
            break
    # Tool-specific defaults appended last (wins on conflicts)
    v = d.get(tool)
    if isinstance(v, list):
        defaults.extend([x for x in v if isinstance(x, str)])

for a in defaults:
    print(a)
PY
}

resolve_persona_json() {
  local json_path="$1" persona_dir="$2" include_root="$3" prefer_repo="$4" extra_paths="$5" persona_home="$6"
  [[ -f "$json_path" ]] || return 0

  if ! grep -q '"include"[[:space:]]*:' "$json_path" 2>/dev/null; then
    echo "$json_path"
    return 0
  fi

  local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || die "persona.json includes require python (python3 or python)"

  local tmp
  tmp="$(mktemp -p "${TMPDIR:-/tmp}" "agent-persona.persona-json.XXXXXX")"
  set +e
  AP_ROOT="$include_root" AP_PREFER_REPO="$prefer_repo" AP_EXTRA_PATHS="$extra_paths" \
    AP_PERSONA_HOME="$persona_home" AP_HOME="$HOME" AP_INCLUDE_DEPTH="$INCLUDE_DEPTH" \
    "$py" - "$json_path" "$persona_dir" <<'PY' > "$tmp"
import json
import os
import sys

json_path = sys.argv[1]
persona_dir = sys.argv[2]

def err(msg):
    print(f"include error: {msg}", file=sys.stderr)
    sys.exit(1)

def load_json(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        err(f"failed to parse {path}: {e}")
    if not isinstance(data, dict):
        err(f"expected object in {path}")
    return data

def find_persona_json(dir_path):
    for name in ("persona.json", "Persona.json", "config.json"):
        cand = os.path.join(dir_path, name)
        if os.path.isfile(cand):
            return cand
    return None

root = os.path.abspath(os.environ.get("AP_ROOT") or os.getcwd())
prefer_repo = os.environ.get("AP_PREFER_REPO", "1") == "1"
extra_paths = [p for p in os.environ.get("AP_EXTRA_PATHS", "").split(":") if p]
home = os.environ.get("AP_HOME") or ""
persona_home = os.environ.get("AP_PERSONA_HOME") or os.path.join(home, ".local/share/agent-persona")
max_depth = int(os.environ.get("AP_INCLUDE_DEPTH", "10"))

def has_persona(base, name):
    if not base:
        return None
    cand = os.path.join(base, name, "AGENTS.md")
    if os.path.isfile(cand):
        return os.path.dirname(cand)
    return None

def scan_repo_upwards(start, name):
    d = os.path.abspath(start)
    while True:
        for base in (".personas", ".persona"):
            found = has_persona(os.path.join(d, base), name)
            if found:
                return found
        if d == "/":
            break
        d = os.path.dirname(d)
    return None

def resolve_persona_dir(name):
    if prefer_repo:
        found = scan_repo_upwards(root, name)
        if found:
            return found
    for p in extra_paths:
        found = has_persona(p, name)
        if found:
            return found
    for base in (os.path.join(home, ".personas"), os.path.join(persona_home, ".personas"), "/usr/local/share/agent-persona/.personas"):
        found = has_persona(base, name)
        if found:
            return found
    if not prefer_repo:
        found = scan_repo_upwards(root, name)
        if found:
            return found
    return None

def resolve_shared_file(rel_path, shared_root):
    if not shared_root:
        err(f"shared root not set for file include: {rel_path}")
    if not isinstance(rel_path, str) or not rel_path:
        err("include file path must be a non-empty string")
    if os.path.isabs(rel_path) or rel_path.startswith("~"):
        err(f"include file must be relative to shared root: {rel_path}")
    base = os.path.abspath(shared_root)
    target = os.path.abspath(os.path.join(base, rel_path))
    if os.path.commonpath([base, target]) != base:
        err(f"include file escapes shared root: {rel_path}")
    if not os.path.isfile(target):
        err(f"include file not found: {target}")
    return target

def merge_list(left, right, normalize=None):
    out = []
    seen = set()
    for item in (left or []) + (right or []):
        if not isinstance(item, str):
            continue
        key = normalize(item) if normalize else item
        if key in seen:
            continue
        seen.add(key)
        out.append(item)
    return out, seen

def merge_defaults(a, b):
    result = {}
    for src in (a, b):
        if not isinstance(src, dict):
            continue
        for key, val in src.items():
            if not isinstance(val, list):
                continue
            dst = result.setdefault(key, [])
            for item in val:
                if item not in dst:
                    dst.append(item)
    return result

def extract_mcp_servers(doc):
    if isinstance(doc.get("mcp"), dict):
        mcp = doc["mcp"]
        servers = mcp.get("servers") or mcp.get("mcpServers")
        if isinstance(servers, dict):
            return servers
    if isinstance(doc.get("mcpServers"), dict):
        return doc["mcpServers"]
    return {}

def merge_mcp(a, b):
    result = dict(a)
    for name, cfg in b.items():
        if not isinstance(name, str):
            continue
        if name in result and result[name] != cfg:
            err(f"mcp server conflict for '{name}'")
        result[name] = cfg
    return result

def merge_policy(a, b):
    pa = a if isinstance(a, dict) else {}
    pb = b if isinstance(b, dict) else {}

    tools_a = pa.get("tools") if isinstance(pa.get("tools"), dict) else {}
    tools_b = pb.get("tools") if isinstance(pb.get("tools"), dict) else {}
    allow, allow_set = merge_list(tools_a.get("allow"), tools_b.get("allow"), normalize=str.lower)
    deny, deny_set = merge_list(tools_a.get("deny"), tools_b.get("deny"), normalize=str.lower)
    if allow_set & deny_set:
        err("policy tools.allow conflicts with tools.deny")

    paths_a = pa.get("paths") if isinstance(pa.get("paths"), dict) else {}
    paths_b = pb.get("paths") if isinstance(pb.get("paths"), dict) else {}
    p_allow, p_allow_set = merge_list(paths_a.get("allow"), paths_b.get("allow"))
    p_deny, p_deny_set = merge_list(paths_a.get("deny"), paths_b.get("deny"))
    if p_allow_set & p_deny_set:
        err("policy paths.allow conflicts with paths.deny")

    net_a = pa.get("network") if isinstance(pa.get("network"), dict) else {}
    net_b = pb.get("network") if isinstance(pb.get("network"), dict) else {}
    n_deny, _ = merge_list(net_a.get("deny"), net_b.get("deny"))

    out = {}
    tools_out = {}
    if allow:
        tools_out["allow"] = allow
    if deny:
        tools_out["deny"] = deny
    if tools_out:
        out["tools"] = tools_out

    paths_out = {}
    if p_allow:
        paths_out["allow"] = p_allow
    if p_deny:
        paths_out["deny"] = p_deny
    if paths_out:
        out["paths"] = paths_out

    if n_deny:
        out["network"] = {"deny": n_deny}

    return out

def merge_docs(base, other):
    result = {}
    for key, val in (base or {}).items():
        if key in ("include", "defaults", "policy", "mcp", "mcpServers"):
            continue
        result[key] = val

    defaults = merge_defaults(base.get("defaults") if isinstance(base, dict) else {}, other.get("defaults") if isinstance(other, dict) else {})
    if defaults:
        result["defaults"] = defaults

    policy = merge_policy(base.get("policy"), other.get("policy"))
    if policy:
        result["policy"] = policy

    mcp = merge_mcp(extract_mcp_servers(base), extract_mcp_servers(other))
    if mcp:
        result["mcpServers"] = mcp

    for key, val in (other or {}).items():
        if key in ("include", "defaults", "policy", "mcp", "mcpServers"):
            continue
        if key not in result:
            result[key] = val
        elif result[key] != val:
            err(f"conflict for key '{key}'")

    return result

def resolve_doc(path, shared_root, depth, stack):
    if depth > max_depth:
        err(f"include depth exceeded ({max_depth}) at {path}")
    abs_path = os.path.realpath(path)
    if abs_path in stack:
        err(f"include cycle detected at {path}")
    stack.append(abs_path)
    doc = load_json(path)
    includes = doc.get("include", [])
    if includes is None:
        includes = []
    if not isinstance(includes, list):
        err(f"include must be an array in {path}")
    merged = {}
    for item in includes:
        if not isinstance(item, dict):
            err(f"include entries must be objects in {path}")
        if "persona" in item and "file" in item:
            err(f"include entry has both persona and file in {path}")
        if "persona" in item:
            name = item.get("persona")
            if not isinstance(name, str) or not name:
                err(f"include persona must be a non-empty string in {path}")
            pdir = resolve_persona_dir(name)
            if not pdir:
                err(f"include persona not found: {name}")
            pjson = find_persona_json(pdir)
            if not pjson:
                err(f"include persona.json not found for {name}")
            next_shared = os.path.join(os.path.dirname(pdir), ".shared")
            merged = merge_docs(merged, resolve_doc(pjson, next_shared, depth + 1, stack))
            continue
        if "file" in item:
            rel = item.get("file")
            fpath = resolve_shared_file(rel, shared_root)
            merged = merge_docs(merged, resolve_doc(fpath, shared_root, depth + 1, stack))
            continue
        err(f"include entry missing persona or file in {path}")

    doc_no_include = {k: v for k, v in doc.items() if k != "include"}
    merged = merge_docs(merged, doc_no_include)
    stack.pop()
    return merged

shared_root = os.path.join(os.path.dirname(persona_dir), ".shared")
result = resolve_doc(json_path, shared_root, 1, [])
json.dump(result, sys.stdout)
PY
  local rc=$?
  set -e
  if [[ $rc -ne 0 ]]; then
    rm -f "$tmp" 2>/dev/null || true
    die "persona.json include resolution failed for $json_path"
  fi
  include_tmp_files+=("$tmp")
  echo "$tmp"
}

extract_mcp_config() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

# Support both "mcp" and "mcpServers" at top level
mcp_servers = None
if isinstance(j.get("mcp"), dict):
    m = j["mcp"]
    mcp_servers = m.get("servers") or m.get("mcpServers")
elif isinstance(j.get("mcpServers"), dict):
    mcp_servers = j["mcpServers"]

if not isinstance(mcp_servers, dict) or not mcp_servers:
    sys.exit(0)

config = {"mcpServers": mcp_servers}
fd, tmp_path = tempfile.mkstemp(prefix="persona-mcp-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(config, f)
print(tmp_path)
PY
}

codex_mcp_overrides_from_json() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, re, sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

def get_mcp_servers(doc):
    if isinstance(doc.get("mcp"), dict):
        m = doc["mcp"]
        v = m.get("servers") or m.get("mcpServers")
        if isinstance(v, dict):
            return v
    if isinstance(doc.get("mcpServers"), dict):
        return doc["mcpServers"]
    return None

mcp_servers = get_mcp_servers(j)
if not isinstance(mcp_servers, dict) or not mcp_servers:
    sys.exit(0)

def toml_value(v):
    # JSON syntax is valid TOML for strings, arrays, booleans, and numbers.
    return json.dumps(v)

def emit(key, value):
    print(f"{key}={toml_value(value)}")

name_re = re.compile(r"^[A-Za-z0-9_]+$")
env_key_re = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")

for name, cfg in mcp_servers.items():
    if not isinstance(name, str) or not name_re.match(name):
        continue
    if not isinstance(cfg, dict):
        continue

    enabled = cfg.get("enabled")
    emit(f"mcp_servers.{name}.enabled", bool(enabled) if isinstance(enabled, bool) else True)

    # HTTP (streamable) servers
    if isinstance(cfg.get("url"), str):
        emit(f"mcp_servers.{name}.url", cfg["url"])
        btev = cfg.get("bearer_token_env_var") or cfg.get("bearerTokenEnvVar")
        if isinstance(btev, str) and btev:
            emit(f"mcp_servers.{name}.bearer_token_env_var", btev)
        continue

    # Stdio servers
    if isinstance(cfg.get("command"), str):
        emit(f"mcp_servers.{name}.command", cfg["command"])
    if isinstance(cfg.get("args"), list) and all(isinstance(x, str) for x in cfg["args"]):
        emit(f"mcp_servers.{name}.args", cfg["args"])
    if isinstance(cfg.get("cwd"), str):
        emit(f"mcp_servers.{name}.cwd", cfg["cwd"])
    if isinstance(cfg.get("env"), dict):
        for k, v in cfg["env"].items():
            if isinstance(k, str) and env_key_re.match(k):
                emit(f"mcp_servers.{name}.env.{k}", str(v))
PY
}

# --- Policy translation: extract policy from persona.json ---
extract_policy() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys
path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy")
if not isinstance(policy, dict):
    sys.exit(0)

# Output policy as JSON for downstream processing
print(json.dumps(policy))
PY
}

# --- Policy translation: get tools.allow list for a tool ---
policy_tools_allow() {
  local json_path="$1" tool_family="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_family" <<'PY' || true
import json, sys

path, tool_family = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict):
    policy = {}
tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}
allow = tools.get("allow", [])
if not isinstance(allow, list):
    sys.exit(0)

# Tool name emit mapping (canonical -> tool-specific)
EMIT_MAPS = {
    "claude": {
        "bash": "Bash", "read": "Read", "write": "Write", "edit": "Edit",
        "glob": "Glob", "grep": "Grep", "webfetch": "WebFetch",
        "websearch": "WebSearch", "task": "Task", "todowrite": "TodoWrite",
        "notebookedit": "NotebookEdit", "askuserquestion": "AskUserQuestion",
    },
    "gemini": {
        "bash": "shell", "read": "read_file", "write": "write_file",
        "edit": "edit_file", "glob": "glob", "grep": "grep",
    },
    "opencode": {
        "bash": "bash", "read": "read", "write": "write", "edit": "edit",
        "glob": "glob", "grep": "grep", "webfetch": "webfetch",
        "websearch": "websearch",
    },
}

emit_map = EMIT_MAPS.get(tool_family, {})
for tool in allow:
    if not isinstance(tool, str):
        continue
    canonical = tool.lower()
    emitted = emit_map.get(canonical, tool)
    print(emitted)
PY
}

# --- Policy translation: get tools.deny list for a tool ---
policy_tools_deny() {
  local json_path="$1" tool_family="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$tool_family" <<'PY' || true
import json, sys

path, tool_family = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict):
    policy = {}
tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}
deny = tools.get("deny", [])
if not isinstance(deny, list):
    sys.exit(0)

# Tool name emit mapping (same as allow)
EMIT_MAPS = {
    "claude": {
        "bash": "Bash", "read": "Read", "write": "Write", "edit": "Edit",
        "glob": "Glob", "grep": "Grep", "webfetch": "WebFetch",
        "websearch": "WebSearch", "task": "Task", "todowrite": "TodoWrite",
        "notebookedit": "NotebookEdit", "askuserquestion": "AskUserQuestion",
    },
    "gemini": {
        "bash": "shell", "read": "read_file", "write": "write_file",
        "edit": "edit_file", "glob": "glob", "grep": "grep",
    },
    "opencode": {
        "bash": "bash", "read": "read", "write": "write", "edit": "edit",
        "glob": "glob", "grep": "grep", "webfetch": "webfetch",
        "websearch": "websearch",
    },
}

emit_map = EMIT_MAPS.get(tool_family, {})
for tool in deny:
    if not isinstance(tool, str):
        continue
    canonical = tool.lower()
    emitted = emit_map.get(canonical, tool)
    print(emitted)
PY
}

# --- Policy translation: generate Claude settings JSON for path deny ---
generate_claude_settings() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict):
    policy = {}
paths = policy.get("paths", {})
if not isinstance(paths, dict):
    paths = {}
deny_paths = paths.get("deny", [])

if not isinstance(deny_paths, list) or not deny_paths:
    sys.exit(0)

# Generate deny rules for each path pattern
deny_rules = []
for p in deny_paths:
    if not isinstance(p, str):
        continue
    # Generate rules for Read, Edit, Write operations on denied paths
    deny_rules.append(f"Read({p})")
    deny_rules.append(f"Edit({p})")
    deny_rules.append(f"Write({p})")

if not deny_rules:
    sys.exit(0)

settings = {"permissions": {"deny": deny_rules}}
fd, tmp_path = tempfile.mkstemp(prefix="persona-claude-settings-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(settings, f)
print(tmp_path)
PY
}

# --- Policy translation: generate Gemini settings JSON ---
generate_gemini_settings() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict) or not policy:
    sys.exit(0)

settings = {"tools": {}, "mcp": {}}

# Tool name mapping for Gemini
GEMINI_MAP = {
    "bash": "shell", "read": "read_file", "write": "write_file",
    "edit": "edit_file", "glob": "glob", "grep": "grep",
}

# tools.allow -> tools.core
tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}
if isinstance(tools.get("allow"), list):
    core = []
    for t in tools["allow"]:
        if not isinstance(t, str):
            continue
        canonical = t.lower()
        core.append(GEMINI_MAP.get(canonical, t))
    if core:
        settings["tools"]["core"] = core

# tools.deny -> tools.exclude
if isinstance(tools.get("deny"), list):
    exclude = []
    for t in tools["deny"]:
        if not isinstance(t, str):
            continue
        canonical = t.lower()
        exclude.append(GEMINI_MAP.get(canonical, t))
    if exclude:
        settings["tools"]["exclude"] = exclude

# mcpServers.allow/deny
mcp = policy.get("mcpServers", {})
if not isinstance(mcp, dict):
    mcp = {}
if isinstance(mcp.get("allow"), list) and mcp["allow"]:
    settings["mcp"]["allowed"] = mcp["allow"]
if isinstance(mcp.get("deny"), list) and mcp["deny"]:
    settings["mcp"]["excluded"] = mcp["deny"]

# Optional: disable IDE integration to avoid companion dependency
disable_ide = os.environ.get("AGENT_PERSONA_GEMINI_DISABLE_IDE", "").strip().lower()
if disable_ide in ("1", "true", "yes"):
    settings["ide"] = {"enabled": False}

# Only write if we have something
if not settings["tools"] and not settings["mcp"] and not settings.get("ide"):
    sys.exit(0)

fd, tmp_path = tempfile.mkstemp(prefix="persona-gemini-settings-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(settings, f)
print(tmp_path)
PY
}

# --- Policy translation: generate OpenCode config JSON ---
generate_opencode_config() {
  local json_path="$1"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" <<'PY' || true
import json, sys, tempfile, os

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict) or not policy:
    sys.exit(0)

config = {"tools": {}, "permission": {}}

# Tool name mapping for OpenCode (mostly lowercase)
OPENCODE_MAP = {
    "bash": "bash", "read": "read", "write": "write", "edit": "edit",
    "glob": "glob", "grep": "grep", "webfetch": "webfetch",
    "websearch": "websearch", "task": "task",
}

tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}

# tools.allow -> permission: { name: "allow" }
if isinstance(tools.get("allow"), list):
    for t in tools["allow"]:
        if not isinstance(t, str):
            continue
        canonical = t.lower()
        mapped = OPENCODE_MAP.get(canonical, t)
        config["permission"][mapped] = "allow"

# tools.deny -> tools: { name: false }
if isinstance(tools.get("deny"), list):
    for t in tools["deny"]:
        if not isinstance(t, str):
            continue
        canonical = t.lower()
        mapped = OPENCODE_MAP.get(canonical, t)
        config["tools"][mapped] = False

# Only write if we have something
if not config["tools"] and not config["permission"]:
    sys.exit(0)

fd, tmp_path = tempfile.mkstemp(prefix="persona-opencode-config-", suffix=".json")
with os.fdopen(fd, "w", encoding="utf-8") as f:
    json.dump(config, f)
print(tmp_path)
PY
}

# --- Policy translation: generate Codex sandbox overrides ---
codex_policy_overrides() {
  local json_path="$1" repo_root="$2"; local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || return 0
  "$py" - "$json_path" "$repo_root" <<'PY' || true
import json, sys, os

path, repo_root = sys.argv[1], sys.argv[2]
try:
    with open(path, "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(0)

policy = j.get("policy", {})
if not isinstance(policy, dict) or not policy:
    sys.exit(0)

overrides = []

# paths.allow -> sandbox_mode + writable_roots
paths = policy.get("paths", {})
if not isinstance(paths, dict):
    paths = {}
if isinstance(paths.get("allow"), list) and paths["allow"]:
    # Normalize paths to absolute
    abs_paths = []
    for p in paths["allow"]:
        if not isinstance(p, str):
            continue
        if p.startswith("./"):
            abs_paths.append(os.path.normpath(os.path.join(repo_root, p[2:])))
        elif p.startswith("~/"):
            abs_paths.append(os.path.expanduser(p))
        elif p.startswith("/"):
            abs_paths.append(p)
        else:
            abs_paths.append(os.path.normpath(os.path.join(repo_root, p)))

    if abs_paths:
        overrides.append('sandbox_mode="workspace-write"')
        overrides.append(f'sandbox_workspace_write.writable_roots={json.dumps(abs_paths)}')

# network.deny -> network_access=false
network = policy.get("network", {})
if not isinstance(network, dict):
    network = {}
if isinstance(network.get("deny"), list) and "*" in network["deny"]:
    overrides.append('sandbox_workspace_write.network_access=false')

# tools.deny (websearch) -> features.web_search_request=false
tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}
if isinstance(tools.get("deny"), list):
    deny_lower = [t.lower() for t in tools["deny"] if isinstance(t, str)]
    if "websearch" in deny_lower:
        overrides.append('features.web_search_request=false')

for ov in overrides:
    print(ov)
PY
}

# --- Helper: resolve instruction file (tool-specific or fallback to AGENTS.md) ---
resolve_instruction_file() {
  local persona_dir="$1" overlay_name="$2"
  local tool_specific="$persona_dir/$overlay_name"

  # Use tool-specific file if it exists and we're not already targeting AGENTS.md
  if [[ -f "$tool_specific" && "$overlay_name" != "AGENTS.md" ]]; then
    echo "$tool_specific"
  else
    echo "$persona_dir/AGENTS.md"
  fi
}

expand_includes() {
  local src="$1" overlay_name="$2" shared_root="$3" include_root="$4" prefer_repo="$5" extra_paths="$6" persona_home="$7" persona_name="$8"
  [[ -f "$src" ]] || die "include source not found: $src"

  # Skip Python if no include directives AND no {{...}} template variables
  if ! grep -q '<!--[[:space:]]*include' "$src" 2>/dev/null && ! grep -q '{{' "$src" 2>/dev/null; then
    echo "$src"
    return 0
  fi

  local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"
  command -v "$py" >/dev/null 2>&1 || die "include directives require python (python3 or python)"

  local tmp
  tmp="$(mktemp -p "${TMPDIR:-/tmp}" "agent-persona.include.XXXXXX")"
  set +e
  AP_ROOT="$include_root" AP_PREFER_REPO="$prefer_repo" AP_EXTRA_PATHS="$extra_paths" \
    AP_PERSONA_HOME="$persona_home" AP_HOME="$HOME" AP_INCLUDE_DEPTH="$INCLUDE_DEPTH" \
    AP_PERSONA_NAME="$persona_name" \
    "$py" - "$src" "$overlay_name" "$shared_root" <<'PY' > "$tmp"
import json
import os
import re
import sys

src_path = sys.argv[1]
overlay_name = sys.argv[2]
shared_root = sys.argv[3]

def err(msg):
    print(f"include error: {msg}", file=sys.stderr)
    sys.exit(1)

def warn(msg):
    print(f"include warning: {msg}", file=sys.stderr)

pattern = re.compile(r"<!--\s*include\s+(\{.*?\})\s*-->")

root = os.path.abspath(os.environ.get("AP_ROOT") or os.getcwd())
prefer_repo = os.environ.get("AP_PREFER_REPO", "1") == "1"
extra_paths = [p for p in os.environ.get("AP_EXTRA_PATHS", "").split(":") if p]
home = os.environ.get("AP_HOME") or ""
persona_home = os.environ.get("AP_PERSONA_HOME") or os.path.join(home, ".local/share/agent-persona")
max_depth = int(os.environ.get("AP_INCLUDE_DEPTH", "10"))

def has_persona(base, name):
    if not base:
        return None
    cand = os.path.join(base, name, "AGENTS.md")
    if os.path.isfile(cand):
        return os.path.dirname(cand)
    return None

def scan_repo_upwards(start, name):
    d = os.path.abspath(start)
    while True:
        for base in (".personas", ".persona"):
            found = has_persona(os.path.join(d, base), name)
            if found:
                return found
        if d == "/":
            break
        d = os.path.dirname(d)
    return None

def resolve_persona_dir(name):
    if prefer_repo:
        found = scan_repo_upwards(root, name)
        if found:
            return found
    for p in extra_paths:
        found = has_persona(p, name)
        if found:
            return found
    for base in (os.path.join(home, ".personas"), os.path.join(persona_home, ".personas"), "/usr/local/share/agent-persona/.personas"):
        found = has_persona(base, name)
        if found:
            return found
    if not prefer_repo:
        found = scan_repo_upwards(root, name)
        if found:
            return found
    return None

def resolve_instruction_file(persona_dir, overlay):
    tool_specific = os.path.join(persona_dir, overlay)
    if overlay != "AGENTS.md" and os.path.isfile(tool_specific):
        return tool_specific
    default_path = os.path.join(persona_dir, "AGENTS.md")
    if os.path.isfile(default_path):
        return default_path
    return None

def resolve_shared_file(rel_path, base_root):
    if not base_root:
        err(f"shared root not set for file include: {rel_path}")
    if not isinstance(rel_path, str) or not rel_path:
        err("include file path must be a non-empty string")
    if os.path.isabs(rel_path) or rel_path.startswith("~"):
        err(f"include file must be relative to shared root: {rel_path}")
    base = os.path.abspath(base_root)
    target = os.path.abspath(os.path.join(base, rel_path))
    if os.path.commonpath([base, target]) != base:
        err(f"include file escapes shared root: {rel_path}")
    if not os.path.isfile(target):
        err(f"include file not found: {target}")
    return target

def expand_line(line, base_root, depth, stack, path, line_no):
    if "<!--" not in line:
        return line
    if "<!-- include" in line and not pattern.search(line):
        warn(f"{path}:{line_no}: include directive must be JSON on a single line (ignoring)")
        return line
    out = []
    last = 0
    for match in pattern.finditer(line):
        out.append(line[last:match.start()])
        raw = match.group(1)
        try:
            data = json.loads(raw)
        except Exception as e:
            err(f"{path}:{line_no}: invalid include JSON: {e}")
        if not isinstance(data, dict):
            err(f"{path}:{line_no}: include entry must be an object")
        if "persona" in data and "file" in data:
            err(f"{path}:{line_no}: include has both persona and file")
        if "persona" in data:
            name = data.get("persona")
            if not isinstance(name, str) or not name:
                err(f"{path}:{line_no}: include persona must be a non-empty string")
            pdir = resolve_persona_dir(name)
            if not pdir:
                err(f"{path}:{line_no}: include persona not found: {name}")
            target = resolve_instruction_file(pdir, overlay_name)
            if not target:
                err(f"{path}:{line_no}: include persona missing instructions: {name}")
            next_shared = os.path.join(os.path.dirname(pdir), ".shared")
            out.append(expand_file(target, next_shared, depth + 1, stack))
        elif "file" in data:
            rel = data.get("file")
            target = resolve_shared_file(rel, base_root)
            out.append(expand_file(target, base_root, depth + 1, stack))
        else:
            err(f"{path}:{line_no}: include entry missing persona or file")
        last = match.end()
    out.append(line[last:])
    return "".join(out)

def expand_file(path, base_root, depth, stack):
    if depth > max_depth:
        err(f"include depth exceeded ({max_depth}) at {path}")
    abs_path = os.path.realpath(path)
    if abs_path in stack:
        err(f"include cycle detected at {path}")
    stack.append(abs_path)
    try:
        with open(path, "r", encoding="utf-8") as f:
            lines = f.read().splitlines(True)
    except Exception as e:
        err(f"failed to read {path}: {e}")
    out_lines = []
    for idx, line in enumerate(lines, start=1):
        out_lines.append(expand_line(line, base_root, depth, stack, path, idx))
    stack.pop()
    return "".join(out_lines)

output = expand_file(src_path, shared_root, 1, [])

# Substitute {{persona}} variable
persona_name = os.environ.get("AP_PERSONA_NAME", "")
if persona_name:
    output = output.replace("{{persona}}", persona_name)

# Warn about any unrecognized {{...}} variables (but don't block)
unrecognized = re.findall(r'\{\{([^}]+)\}\}', output)
for var in unrecognized:
    warn(f"unrecognized template variable: {{{{{var}}}}}")

sys.stdout.write(output)
PY
  local rc=$?
  set -e
  if [[ $rc -ne 0 ]]; then
    rm -f "$tmp" 2>/dev/null || true
    die "include expansion failed for $src"
  fi
  include_tmp_files+=("$tmp")
  echo "$tmp"
}

# --- Helper: normalize persona directory (handles file-vs-dir profiles) ---
get_persona_dir() {
  local persona_src="$1" profile_type="$2"
  if [[ "$profile_type" == "file" ]]; then
    dirname -- "$persona_src"
  else
    echo "$persona_src"
  fi
}

# --- Helper: check if policy exists in persona.json ---
policy_exists_in_json() {
  local json_path="$1"
  [[ -f "$json_path" ]] || return 1
  grep -qE '"policy"\s*:' "$json_path" 2>/dev/null
}

# --- Helper: filter user args that conflict with policy ---
# Uses index-aware iteration to handle two-token flags (--flag value)
# Outputs null-delimited args for safe array construction
filter_user_args() {
  local tool="$1" has_policy="$2"
  shift 2
  local -a user_args=("$@")

  # If no policy, pass through unchanged
  if [[ "$has_policy" -eq 0 ]]; then
    printf '%s\0' "${user_args[@]}"
    return 0
  fi

  # Policy-controlled flags per tool
  local -a claude_controlled=(
    "--permission-mode"
    "--dangerously-skip-permissions"
    "--tools"
    "--allowedTools"
    "--disallowedTools"
    "--settings"
  )

  local -a codex_controlled_prefixes=(
    "sandbox_mode="
    "sandbox_workspace_write."
    "features.web_search_request"
  )

  local -a codex_controlled_flags=(
    "--dangerously-bypass-approvals-and-sandbox"
    "--yolo"
    "--full-auto"
  )

  local -a filtered=()
  local i=0
  local n=${#user_args[@]}

  while (( i < n )); do
    local arg="${user_args[i]}"
    local skip=0
    local skip_next=0

    case "$tool" in
      claude|claude-code)
        for flag in "${claude_controlled[@]}"; do
          if [[ "$arg" == "$flag" ]]; then
            skip=1
            skip_next=1
            log "filtering policy-controlled flag: $arg ${user_args[i+1]:-}"
            break
          elif [[ "$arg" == "$flag="* ]]; then
            skip=1
            log "filtering policy-controlled flag: $arg"
            break
          fi
        done
        ;;

      codex)
        # Check standalone flags
        for flag in "${codex_controlled_flags[@]}"; do
          if [[ "$arg" == "$flag" ]]; then
            skip=1
            log "filtering policy-controlled flag: $arg"
            break
          fi
        done

        # Check -c config overrides
        if [[ $skip -eq 0 && "$arg" == "-c" ]]; then
          local next="${user_args[i+1]:-}"
          for prefix in "${codex_controlled_prefixes[@]}"; do
            if [[ "$next" == "$prefix"* ]]; then
              skip=1
              skip_next=1
              log "filtering policy-controlled config: -c $next"
              break
            fi
          done
        fi
        ;;

      # Gemini and OpenCode use env vars for config, no CLI flags to filter
    esac

    if (( skip == 0 )); then
      filtered+=("$arg")
    fi

    (( ++i ))
    if (( skip_next == 1 && i < n )); then
      (( ++i ))
    fi
  done

  printf '%s\0' "${filtered[@]}"
}

# --- Helper: filter persona/tool defaults when user overrides them ---
# Goal: user args should override persona.json defaults even for "first one wins" CLIs.
# Inputs:
#   filter_defaults_by_user_overrides <tool> <defaults...> -- <user_args...>
# Output: null-delimited filtered defaults
filter_defaults_by_user_overrides() {
  local tool="$1"
  shift

  local -a defaults=() user_args=()
  local parsing_defaults=1
  for a in "$@"; do
    if [[ "$parsing_defaults" == "1" && "$a" == "--" ]]; then
      parsing_defaults=0
      continue
    fi
    if [[ "$parsing_defaults" == "1" ]]; then
      defaults+=("$a")
    else
      user_args+=("$a")
    fi
  done

  declare -A user_flags=()
  declare -A user_kv_keys=()

  # Track user-provided flags and Codex -c key overrides
  local i=0 n=${#user_args[@]}
  while (( i < n )); do
    local arg="${user_args[i]}"
    if [[ "$arg" == --*=* ]]; then
      user_flags["${arg%%=*}"]=1
    elif [[ "$arg" == --* ]]; then
      user_flags["$arg"]=1
    elif [[ "$tool" == "codex" && "$arg" == "-c" ]]; then
      local next="${user_args[i+1]:-}"
      local key="${next%%=*}"
      [[ -n "$key" ]] && user_kv_keys["$key"]=1
      (( ++i ))
    fi
    (( ++i ))
  done

  local -a tool_value_flags=()
  case "$tool" in
    claude|claude-code)
      tool_value_flags=(--permission-mode --tools --allowedTools --disallowedTools --settings --mcp-config)
      ;;
  esac

  declare -A value_flag_set=()
  for f in "${tool_value_flags[@]}"; do value_flag_set["$f"]=1; done

  local -a filtered=()
  i=0
  n=${#defaults[@]}
  while (( i < n )); do
    local arg="${defaults[i]}"
    local skip=0
    local skip_next=0

    # Tool: codex -c key=... defaults overridden by user -c key=...
    if [[ "$tool" == "codex" && "$arg" == "-c" ]]; then
      local next="${defaults[i+1]:-}"
      local key="${next%%=*}"
      if [[ -n "$key" && -n "${user_kv_keys[$key]:-}" ]]; then
        skip=1
        skip_next=1
      fi
    fi

    # Common: exact flag match or flag=... overridden by user
    if (( skip == 0 )); then
      local flag_name="$arg"
      if [[ "$arg" == --*=* ]]; then
        flag_name="${arg%%=*}"
      fi
      if [[ -n "${user_flags[$flag_name]:-}" ]]; then
        skip=1
        if [[ "$arg" != --*=* && -n "${value_flag_set[$flag_name]:-}" ]]; then
          skip_next=1
        fi
      fi
    fi

    if (( skip == 0 )); then
      filtered+=("$arg")
    fi

    (( ++i ))
    if (( skip_next == 1 && i < n )); then
      (( ++i ))
    fi
  done

  printf '%s\0' "${filtered[@]}"
}

# --- Helper: check strict policy enforcement capabilities ---
check_strict_policy() {
  local tool="$1" json_cfg="$2"
  local -a failures=()
  local -a warnings=()
  local py="python3"
  command -v python3 >/dev/null 2>&1 || py="python"

  # Get policy elements with safe parsing (avoid shell quoting issues)
  local has_tools_allow=0 has_tools_deny=0 has_paths_allow=0 has_paths_deny=0
  local has_network_deny=0 bash_allowed=1
  local policy_flags
  policy_flags="$("$py" - "$json_cfg" <<'PY' 2>/dev/null || true
import json, sys
try:
    with open(sys.argv[1], "r", encoding="utf-8") as f:
        j = json.load(f)
except Exception:
    sys.exit(1)

policy = j.get("policy", {})
if not isinstance(policy, dict):
    sys.exit(2)

tools = policy.get("tools", {})
if not isinstance(tools, dict):
    tools = {}
paths = policy.get("paths", {})
if not isinstance(paths, dict):
    paths = {}
network = policy.get("network", {})
if not isinstance(network, dict):
    network = {}

allow_tools = [t for t in tools.get("allow", []) if isinstance(t, str)]
deny_tools = [t for t in tools.get("deny", []) if isinstance(t, str)]
has_tools_allow = 1 if allow_tools else 0
has_tools_deny = 1 if deny_tools else 0

allow_paths = [p for p in paths.get("allow", []) if isinstance(p, str)]
deny_paths = [p for p in paths.get("deny", []) if isinstance(p, str)]
has_paths_allow = 1 if allow_paths else 0
has_paths_deny = 1 if deny_paths else 0

net_deny = network.get("deny", [])
has_network_deny = 1 if isinstance(net_deny, list) and "*" in net_deny else 0

allow_lower = [t.lower() for t in allow_tools]
deny_lower = [t.lower() for t in deny_tools]
if allow_lower:
    bash_allowed = 1 if "bash" in allow_lower else 0
else:
    bash_allowed = 0 if "bash" in deny_lower else 1

print(f"{has_tools_allow} {has_tools_deny} {has_paths_allow} {has_paths_deny} {has_network_deny} {bash_allowed}")
PY
)"

  if [[ -z "$policy_flags" ]]; then
    failures+=("policy: failed to parse policy JSON")
  else
    read -r has_tools_allow has_tools_deny has_paths_allow has_paths_deny has_network_deny bash_allowed <<<"$policy_flags"
  fi

  case "$tool" in
    claude|claude-code)
      # Claude: tools.allow/deny supported, paths.deny partial, network weak
      if [[ "$has_paths_deny" == "1" ]]; then
        warnings+=("paths.deny: Claude path deny rules have known edge-cases with MCP tools")
      fi
      if [[ "$has_network_deny" == "1" && "$bash_allowed" == "1" ]]; then
        failures+=("network.deny: Claude cannot enforce when bash allowed (shell can curl/wget)")
      fi
      ;;

    codex)
      # Codex: strong sandbox, but paths.deny not supported
      if [[ "$has_paths_deny" == "1" ]]; then
        failures+=("paths.deny: Codex sandbox does not support deny-only paths (use paths.allow)")
      fi
      ;;

    gemini)
      # Gemini: tools supported, paths not supported
      if [[ "$has_paths_allow" == "1" || "$has_paths_deny" == "1" ]]; then
        failures+=("paths: Gemini does not support path restrictions")
      fi
      if [[ "$has_network_deny" == "1" && "$bash_allowed" == "1" ]]; then
        warnings+=("network.deny: only blocks web tools, not shell network access")
      fi
      ;;

    opencode)
      # OpenCode: tools supported, paths partial
      if [[ "$has_network_deny" == "1" && "$bash_allowed" == "1" ]]; then
        warnings+=("network.deny: only blocks web tools, not shell network access")
      fi
      ;;

    *)
      failures+=("tool '$tool' does not have policy translation support")
      ;;
  esac

  # Report warnings
  for w in "${warnings[@]}"; do
    warn "strict-policy: $w"
  done

  # Report and fail on failures
  if (( ${#failures[@]} > 0 )); then
    for f in "${failures[@]}"; do
      echo "[FAIL] $f" >&2
    done
    die "strict-policy: ${#failures[@]} enforcement failure(s) - policy cannot be reliably enforced"
  fi
}

# --- Subcommand: print-policy ---
cmd_print_policy() {
  local tool="" persona=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*)
        die "unknown flag: $1" ;;
      *)
        if [[ -z "$tool" ]]; then
          tool="$1"
        elif [[ -z "$persona" ]]; then
          persona="$1"
        fi
        shift
        ;;
    esac
  done

  tool="${tool:-codex}"
  [[ -n "$persona" ]] || die "usage: agent-persona print-policy <tool> <persona>"

  # Determine overlay filename
  local overlay_name="AGENTS.md"
  case "$tool" in
    claude|claude-code) overlay_name="CLAUDE.md" ;;
    gemini) overlay_name="GEMINI.md" ;;
  esac

  # Resolve persona
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" && root="$(pwd -P)"

  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local persona_dir=""

  for base in "$root/.personas" "$root/.persona" "$HOME/.personas" "$PERSONA_HOME/.personas" "/usr/local/share/agent-persona/.personas"; do
    if [[ -d "$base/$persona" && -f "$base/$persona/AGENTS.md" ]]; then
      persona_dir="$base/$persona"
      break
    fi
  done

  [[ -n "$persona_dir" ]] || die "persona '$persona' not found"

  # Check for persona.json
  local json_cfg=""
  for cand in "$persona_dir/persona.json" "$persona_dir/Persona.json" "$persona_dir/config.json"; do
    [[ -f "$cand" ]] && { json_cfg="$cand"; break; }
  done
  local json_cfg_resolved="$json_cfg"
  if [[ -n "$json_cfg" ]]; then
    local PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
    local EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"
    json_cfg_resolved="$(resolve_persona_json "$json_cfg" "$persona_dir" "$root" "$PREFER_REPO" "$EXTRA_PATHS" "$PERSONA_HOME")"
    [[ -n "$json_cfg_resolved" ]] || json_cfg_resolved="$json_cfg"
  fi

  echo "=== Policy Summary ==="
  echo ""
  echo "Persona:        $persona"
  echo "Persona dir:    $persona_dir"
  echo "Tool:           $tool"
  echo "Overlay file:   $overlay_name"
  echo ""

  echo "=== Environment Variables (exported to tool) ==="
  echo "AGENT_PERSONA_NAME=$persona"
  echo "AGENT_PERSONA_PATH=$persona_dir"
  echo "AGENT_PERSONA_TOOL=$tool"
  echo "AGENT_PERSONA_OVERLAY_FILE=$overlay_name"
  echo ""

  if [[ -z "$json_cfg_resolved" ]]; then
    echo "=== Policy ==="
    echo "(no persona.json found)"
    return 0
  fi

  if ! policy_exists_in_json "$json_cfg_resolved"; then
    echo "=== Policy ==="
    echo "(no policy block in persona.json)"
    return 0
  fi

  echo "=== Policy Source ==="
  echo "$json_cfg"
  echo ""

  echo "=== Policy Content ==="
  local py=""
  if command -v python3 >/dev/null 2>&1; then
    py="python3"
  elif command -v python >/dev/null 2>&1; then
    py="python"
  fi
  if [[ -z "$py" ]]; then
    echo "(python not found; unable to parse policy)"
  else
    "$py" - "$json_cfg_resolved" <<'PY'
import json, sys
try:
    with open(sys.argv[1]) as f:
        j = json.load(f)
    policy = j.get("policy", {})
    print(json.dumps(policy, indent=2))
except Exception as e:
    print(f"Error: {e}")
PY
  fi
  echo ""

  echo "=== Policy Translation for $tool ==="
  case "$tool" in
    claude|claude-code)
      echo "Tool flags:"
      mapfile -t allowed < <(policy_tools_allow "$json_cfg_resolved" "claude")
      if (( ${#allowed[@]} > 0 )); then
        echo "  --allowedTools $(IFS=','; echo "${allowed[*]}")"
      fi
      mapfile -t denied < <(policy_tools_deny "$json_cfg_resolved" "claude")
      if (( ${#denied[@]} > 0 )); then
        echo "  --disallowedTools $(IFS=','; echo "${denied[*]}")"
      fi
      local settings
      settings="$(generate_claude_settings "$json_cfg_resolved" 2>/dev/null)" || settings=""
      if [[ -n "$settings" && -f "$settings" ]]; then
        echo "  --settings <temp file with path deny rules>"
        rm -f "$settings"
      fi
      ;;

    codex)
      echo "Config overrides:"
      while IFS= read -r ov; do
        [[ -n "$ov" ]] && echo "  -c $ov"
      done < <(codex_policy_overrides "$json_cfg_resolved" "$root")
      ;;

    gemini)
      echo "Settings file via GEMINI_CLI_SYSTEM_SETTINGS_PATH"
      local settings
      settings="$(generate_gemini_settings "$json_cfg_resolved" 2>/dev/null)" || settings=""
      if [[ -n "$settings" && -f "$settings" ]]; then
        cat "$settings"
        rm -f "$settings"
      fi
      ;;

    opencode)
      echo "Config file via OPENCODE_CONFIG"
      local config
      config="$(generate_opencode_config "$json_cfg_resolved" 2>/dev/null)" || config=""
      if [[ -n "$config" && -f "$config" ]]; then
        cat "$config"
        rm -f "$config"
      fi
      ;;

    *)
      echo "(no policy translation for $tool)"
      ;;
  esac
  echo ""

  echo "=== Enforcement Notes ==="
  case "$tool" in
    claude|claude-code)
      echo "- tools.allow/deny: Strong (via --allowedTools, --disallowedTools)"
      echo "- paths.deny: Partial (Claude has edge-cases with MCP tools)"
      echo "- network.deny: Weak if bash allowed (shell can curl/wget)"
      ;;
    codex)
      echo "- sandbox: Strong (workspace-write mode with writable_roots)"
      echo "- network: Strong (network_access=false)"
      echo "- paths.deny: Not supported (use paths.allow instead)"
      ;;
    gemini)
      echo "- tools: Strong (via tools.core, tools.exclude)"
      echo "- paths: Not supported"
      echo "- network: Partial (only blocks web tools)"
      ;;
    opencode)
      echo "- tools: Strong (via tools, permission config)"
      echo "- paths: Partial"
      echo "- network: Partial (only blocks web tools)"
      ;;
  esac
}

# --- Subcommand: init ---
cmd_init() {
  local target="${1:-.}"
  local repo_root
  repo_root="$(resolve_repo_root "$target" 2>/dev/null || echo "$target")"

  local personas_dir="$repo_root/.personas"
  local legacy_dir="$repo_root/.persona"
  local shared_dir="$personas_dir/.shared"

  if [[ -d "$personas_dir" ]]; then
    info ".personas/ already exists at $repo_root"
  else
    mkdir -p "$personas_dir"
    info "Created $personas_dir/"
    [[ -d "$legacy_dir" ]] && info "Note: legacy $legacy_dir/ exists (prefer $personas_dir/)"
  fi

  if [[ ! -d "$shared_dir" ]]; then
    mkdir -p "$shared_dir"
    info "  - Created $shared_dir/"
  fi

  if [[ ! -f "$shared_dir/meta.AGENTS.md" ]]; then
    # Create a starter meta file (ignored until edited)
    default_meta_template > "$shared_dir/meta.AGENTS.md"
    info "  - .shared/meta.AGENTS.md (repo-wide instructions; ignored until edited)"
  else
    info "  - .shared/meta.AGENTS.md already exists"
  fi

  if [[ ! -f "$personas_dir/README.md" ]]; then
    default_readme_template > "$personas_dir/README.md"
    info "  - README.md (how .personas/ works)"
	  else
	    info "  - README.md already exists"
	  fi

	  # Starter shared blocks (for include directives)
	  if [[ ! -f "$shared_dir/agent-contract-posture.md" ]]; then
	    cat > "$shared_dir/agent-contract-posture.md" <<'SNIP'
# Agent Contract Posture

This snippet defines how the agent should interpret the userâ€™s intent, handle risk, and behave under uncertainty.

## Default Stance

- Prefer correctness and safety over speed.
- Ask clarifying questions when requirements are ambiguous.
- Keep changes focused; avoid scope creep.

## Consent & Risk

- Never run destructive commands (e.g., `rm -rf`, `git reset --hard`, `git clean -fdx`) unless the user explicitly asks.
- Never expose secrets, credentials, tokens, or private keys.
- If a request could have unintended side effects, explain the risk and ask before proceeding.

## Reliability

- Donâ€™t guess. If information is missing, say what you need.
- Validate changes with the smallest relevant checks/tests when available.
SNIP
	    info "  - .shared/agent-contract-posture.md (shared block)"
	  else
	    info "  - .shared/agent-contract-posture.md already exists"
	  fi

	  if [[ ! -f "$shared_dir/communication-discipline.md" ]]; then
	    cat > "$shared_dir/communication-discipline.md" <<'SNIP'
# Communication Discipline

This snippet keeps interactions crisp, predictable, and easy to audit.

## Style

- Be concise and information-dense.
- Use clear structure (headings/bullets) when it improves scanability.
- Avoid filler acknowledgements; start with the answer/action.

## Coordination

- Confirm assumptions that materially affect the outcome.
- When proposing a change, include the exact command(s) or file path(s) needed to verify it.
- If something is blocked (permissions/network/tooling), say what would unblock it.
SNIP
	    info "  - .shared/communication-discipline.md (shared block)"
	  else
	    info "  - .shared/communication-discipline.md already exists"
	  fi

	  if [[ ! -f "$shared_dir/knowledge-dilligence.md" ]]; then
	    cat > "$shared_dir/knowledge-dilligence.md" <<'SNIP'
# Knowledge Dilligence

This snippet reduces hallucinations and improves correctness when working with code, docs, or external tools.

## Accuracy Rules

- Donâ€™t invent APIs, flags, or file paths; verify by reading the repo or running `--help`.
- If youâ€™re unsure, ask or propose a safe exploratory command.
- When describing behavior, tie it to a specific implementation detail (function/file), not intuition.

## Verification

- Prefer deterministic checks (unit tests, parsing, static checks) over â€œit seems rightâ€.
- When something canâ€™t be validated automatically, provide a minimal, explicit manual check.
SNIP
	    info "  - .shared/knowledge-dilligence.md (shared block)"
	  else
	    info "  - .shared/knowledge-dilligence.md already exists"
	  fi

	  if [[ ! -f "$shared_dir/continuity.md" ]]; then
	    cat > "$shared_dir/continuity.md" <<'SNIP'
# Continuity

This snippet helps the agent maintain context and avoid regressions across multi-step work.

## State Management

- Keep an explicit list of decisions and constraints (what/why).
- Donâ€™t silently change previously agreed semantics; call it out if revisiting.
- Prefer small, reversible changes; keep diffs easy to review.

## Handoffs

- Summarize what changed and where (file paths).
- Call out remaining follow-ups, edge cases, and how to test.
SNIP
	    info "  - .shared/continuity.md (shared block)"
	  else
	    info "  - .shared/continuity.md already exists"
	  fi

	  # Starter personas (blank + template)
	  local blank_dir="$personas_dir/blank"
	  if [[ ! -d "$blank_dir" ]]; then
	    mkdir -p "$blank_dir"
	    info "  - Created blank/ persona"
	  fi
	  if [[ ! -f "$blank_dir/AGENTS.md" ]]; then
	    : > "$blank_dir/AGENTS.md"
	    info "  - blank/AGENTS.md (empty persona)"
	  else
	    info "  - blank/AGENTS.md already exists"
	  fi

	  local template_dir="$personas_dir/template"
	  if [[ ! -d "$template_dir" ]]; then
	    mkdir -p "$template_dir"
	    info "  - Created template/ persona"
	  fi
	  if [[ ! -f "$template_dir/AGENTS.md" ]]; then
	    cat > "$template_dir/AGENTS.md" <<'AGENTS'
# Example Persona

A demonstration persona showing a recommended structure for agent instruction files.

## Shared Building Blocks

<!-- include {"file":"agent-contract-posture.md"} -->
<!-- include {"file":"communication-discipline.md"} -->
<!-- include {"file":"knowledge-dilligence.md"} -->
<!-- include {"file":"continuity.md"} -->

## Purpose
<!-- What is this agent's primary mission? Keep it to 1-2 sentences. -->
Demonstrate best practices for writing agent personas.

## Success Criteria
<!-- How do we know the agent is doing its job well? -->
- Responses follow the guidelines below
- Work is documented and traceable
- User intent is clarified before major actions

## Scope
**In scope:**
- Tasks explicitly requested by the user
- Clarifying questions when requirements are ambiguous

**Out of scope:**
- Autonomous actions beyond what was requested
- Modifications to unrelated code or files

## Operating Mode
<!-- How should the agent behave? What's its default stance? -->
- **Ask before acting** on anything that could have unintended consequences
- **Explain reasoning** when making non-obvious decisions
- **Stay focused** on the task at hand; avoid scope creep

## Dials
<!-- Tunable parameters. Adjust these to change agent behavior. -->
| Dial | Setting | Notes |
|------|---------|-------|
| Autonomy | Medium | Ask for approval on significant changes |
| Verbosity | Medium | Explain important decisions, skip trivia |
| Tool use | As needed | Use tools when they help, not for show |

## Guardrails
<!-- Hard constraints that should never be violated -->
- Never commit secrets or credentials
- Never delete files without explicit confirmation
- Never push to protected branches without review

## Example Prompts
<!-- Sample interactions to calibrate the agent -->

**Good prompt:**
> "Add input validation to the signup form. Check that email is valid and password is at least 8 characters."

**Vague prompt (agent should clarify):**
> "Make the app better."
> Agent: "Could you clarify what aspect you'd like to improve? For example: performance, UX, code quality, or a specific feature?"
AGENTS
	    info "  - template/AGENTS.md (starter persona)"
	  else
	    info "  - template/AGENTS.md already exists"
	  fi

	  info ""
	  info "Next steps:"
  info "  1. Edit .personas/.shared/meta.AGENTS.md with your project context"
  info "  2. Add personas: mkdir .personas/my-persona && edit .personas/my-persona/AGENTS.md"
  info "  3. Launch: agent-persona claude my-persona"
}

# --- Subcommand: doctor ---
cmd_doctor() {
  local issues=0

  info "Checking agent-persona installation..."
  echo ""

  # Check Bash version (policy features require Bash 4+)
  local bash_major="${BASH_VERSINFO[0]}"
  if (( bash_major >= 4 )); then
    echo "[ok] Bash $BASH_VERSION (policy features supported)"
  else
    echo "[!!] Bash $BASH_VERSION detected; policy features require Bash 4+"
    issues=$((issues + 1))
  fi

  # Check Python (required for policy enforcement)
  if command -v python3 >/dev/null 2>&1; then
    echo "[ok] Python 3 available (policy enforcement supported)"
  elif command -v python >/dev/null 2>&1; then
    echo "[ok] Python available (policy enforcement supported)"
  else
    echo "[--] Python not found (policy features will be unavailable)"
  fi

  # Check launcher
  if command -v agent-persona >/dev/null 2>&1; then
    echo "[ok] agent-persona found: $(command -v agent-persona)"
  else
    echo "[!!] agent-persona not in PATH"
    issues=$((issues + 1))
  fi

  # Check tool shims
  for shim in codex-persona claude-persona gemini-persona opencode-persona; do
    if command -v "$shim" >/dev/null 2>&1; then
      echo "[ok] $shim found"
    else
      echo "[--] $shim not found (optional)"
    fi
  done

  # Check persona directories
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  echo ""
  info "Checking persona directories..."

  local have_personas=0
  if [[ -d "$HOME/.personas" ]]; then
    local count
    count=$(find "$HOME/.personas" -maxdepth 1 -type d | wc -l)
    echo "[ok] Home personas: $HOME/.personas ($((count - 1)) personas)"
    have_personas=1
  fi
  if [[ -d "$PERSONA_HOME/.personas" ]]; then
    local count
    count=$(find "$PERSONA_HOME/.personas" -maxdepth 1 -type d | wc -l)
    echo "[ok] Installed personas: $PERSONA_HOME/.personas ($((count - 1)) personas)"
    have_personas=1
  fi
  if [[ $have_personas -eq 0 ]]; then
    echo "[--] No persona directories found"
  fi

  # Check for orphaned backups (swap-mode leftovers)
  echo ""
  info "Checking for orphaned state..."

  local orphans=0
  if compgen -G "$STATE_DIR/*.backup" >/dev/null 2>&1; then
    for backup in "$STATE_DIR"/*.backup; do
      [[ -f "$backup" ]] || continue
      echo "[!!] Orphaned backup: $backup"
      orphans=$((orphans + 1))
      issues=$((issues + 1))
    done
  fi

  if [[ $orphans -eq 0 ]]; then
    echo "[ok] No orphaned backups"
  else
    echo ""
    info "Run 'agent-persona recover' to restore orphaned files"
  fi

  # Check unshare capability
  echo ""
  info "Checking overlay mechanism..."

  if command -v unshare >/dev/null 2>&1; then
    # Test if unshare works
    if unshare -Um true 2>/dev/null; then
      echo "[ok] unshare available (bind-mount overlay, no on-disk changes)"
    else
      echo "[--] unshare exists but unprivileged user namespaces disabled"
      echo "     Will use swap-and-restore (has small risk on hard-kill)"
    fi
  else
    echo "[--] unshare not found, will use swap-and-restore"
  fi

  echo ""
  if [[ $issues -eq 0 ]]; then
    info "All checks passed"
  else
    info "$issues issue(s) found"
  fi

  return $issues
}

# --- Subcommand: recover ---
cmd_recover() {
  local recovered=0

  info "Scanning for orphaned backups..."

  if compgen -G "$STATE_DIR/*.backup" >/dev/null 2>&1; then
    for backup in "$STATE_DIR"/*.backup; do
      [[ -f "$backup" ]] || continue

      # Metadata file holds original path (same prefix, .meta suffix)
      local meta_file="${backup%.backup}.meta"

      if [[ -f "$meta_file" ]]; then
        local original_path
        original_path="$(cat "$meta_file")"

        if [[ -n "$original_path" ]]; then
          info "Restoring: $original_path"
          cp -a "$backup" "$original_path" && rm -f "$backup" "$meta_file"
          recovered=$((recovered + 1))
        fi
      else
        echo "[??] Orphan without metadata: $backup"
        echo "     Cannot determine original location. Manual review needed."
      fi
    done
  fi

  if [[ $recovered -eq 0 ]]; then
    info "No backups to recover"
  else
    info "Recovered $recovered file(s)"
  fi
}

# --- Subcommand: which / explain ---
cmd_which() {
  local persona="$1"
  [[ -n "$persona" ]] || die "usage: agent-persona which <persona>"

  # Resolve persona (reuse resolution logic)
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" && root="$(pwd -P)"

  local PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

  local profile_type="" persona_src=""

  try_resolve_persona_dir() {
    local base="$1"
    if [[ -f "$base/$persona/AGENTS.md" ]]; then
      profile_type="file"; persona_src="$base/$persona/AGENTS.md"; return 0
    elif [[ -d "$base/$persona" ]]; then
      profile_type="dir"; persona_src="$base/$persona"; return 0
    fi
    return 1
  }

  _scan_repo_upwards() {
    local dir="$1"
    while true; do
      try_resolve_persona_dir "$dir/.personas" && return 0
      try_resolve_persona_dir "$dir/.persona" && return 0
      [[ "$dir" == "/" ]] && break
      dir="$(dirname -- "$dir")"
    done
    return 1
  }

  # Resolution
  if [[ "$PREFER_REPO" == "1" ]]; then
    _scan_repo_upwards "$root" || true
  fi
  if [[ -z "$persona_src" && -n "$EXTRA_PATHS" ]]; then
    IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
    for p in "${arr[@]:-}"; do
      [[ -n "$p" ]] && try_resolve_persona_dir "$p" && break
    done
  fi
  if [[ -z "$persona_src" ]]; then
    try_resolve_persona_dir "$HOME/.personas" || \
    try_resolve_persona_dir "$PERSONA_HOME/.personas" || \
    try_resolve_persona_dir "/usr/local/share/agent-persona/.personas" || true
  fi

  if [[ -z "$persona_src" ]]; then
    die "persona '$persona' not found"
  fi

  # Find repo meta
  local repo_root meta_path=""
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"
  if [[ "$META_ENABLED" != "0" ]]; then
    if [[ -n "$META_FILE_OVERRIDE" ]]; then
      meta_path="$META_FILE_OVERRIDE"
      [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
      if [[ -f "$meta_path" ]]; then
        meta_is_unedited_template "$meta_path" && meta_path=""
      else
        meta_path=""
      fi
    else
      for cand in ".personas/.shared/meta.AGENTS.md" ".personas/.shared/meta.agents.md" \
        ".personas/meta.AGENTS.md" ".personas/meta.agents.md" \
        ".persona/.shared/meta.AGENTS.md" ".persona/.shared/meta.agents.md" \
        ".persona/meta.AGENTS.md" ".persona/meta.agents.md" \
        "meta.AGENTS.md" "meta.agents.md"; do
        cand_path="$repo_root/$cand"
        if [[ -f "$cand_path" ]]; then
          if meta_is_unedited_template "$cand_path"; then
            log "skipping unedited meta template: $cand_path"
            continue
          fi
          meta_path="$cand_path"
          break
        fi
      done
    fi
  fi

  # Report
  echo "Persona:      $persona"
  echo "Source:       $persona_src"
  echo "Repo root:    $repo_root"
  echo "Meta file:    ${meta_path:-<none>}"
  echo "Meta enabled: $([[ "$META_ENABLED" == "0" ]] && echo "no" || echo "yes")"
  echo "Meta position: $META_POSITION"
  echo ""

  # Check overlay mechanism
  if [[ "$FORCE_SWAP" == "1" ]]; then
    echo "Overlay:      swap-and-restore (forced via --force-swap)"
  elif command -v unshare >/dev/null 2>&1 && unshare -Um true 2>/dev/null; then
    echo "Overlay:      bind-mount (via unshare, no on-disk change)"
  else
    echo "Overlay:      swap-and-restore (unshare unavailable)"
    echo "              NOTE: Small risk on hard-kill; use 'recover' if needed"
  fi
}

# --- Subcommand: print-overlay / --dry-run ---
cmd_print_overlay() {
  local tool="" persona=""

  # Parse arguments including flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-meta) META_ENABLED="0"; shift ;;
      --meta-position=*) META_POSITION="${1#*=}"; shift ;;
      --meta-position)
        shift
        [[ $# -gt 0 ]] || die "--meta-position requires a value"
        META_POSITION="$1"; shift
        ;;
      --meta-file=*) META_FILE_OVERRIDE="${1#*=}"; shift ;;
      --meta-file)
        shift
        [[ $# -gt 0 ]] || die "--meta-file requires a value"
        META_FILE_OVERRIDE="$1"; shift
        ;;
      -*)
        die "unknown flag: $1" ;;
      *)
        if [[ -z "$tool" ]]; then
          tool="$1"
        elif [[ -z "$persona" ]]; then
          persona="$1"
        fi
        shift
        ;;
    esac
  done

  tool="${tool:-codex}"
  [[ -n "$persona" ]] || die "usage: agent-persona print-overlay <tool> <persona>"

  # Determine overlay filename
  local overlay_name="AGENTS.md"
  case "$tool" in
    claude|claude-code) overlay_name="CLAUDE.md" ;;
    gemini) overlay_name="GEMINI.md" ;;
  esac

  # Resolve persona
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" && root="$(pwd -P)"

  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local persona_dir=""

  # Find persona directory
  for base in "$root/.personas" "$root/.persona" "$HOME/.personas" "$PERSONA_HOME/.personas" "/usr/local/share/agent-persona/.personas"; do
    if [[ -d "$base/$persona" && -f "$base/$persona/AGENTS.md" ]]; then
      persona_dir="$base/$persona"
      break
    fi
  done

  [[ -n "$persona_dir" ]] || die "persona '$persona' not found"

  # Ensure README.md exists in repo persona directory
  ensure_persona_dir_readme "$persona_dir"

  # Resolve instruction file (tool-specific or fallback to AGENTS.md)
  local persona_src
  persona_src="$(resolve_instruction_file "$persona_dir" "$overlay_name")"
  [[ -f "$persona_src" ]] || die "instruction file not found: $persona_src"

  local include_root="$root"
  local include_prefer_repo="${AGENT_PERSONA_PREFER_REPO:-1}"
  local include_extra_paths="${AGENT_PERSONA_PATHS:-}"
  local include_persona_home="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local persona_shared_root
  persona_shared_root="$(dirname "$persona_dir")/.shared"
  local persona_src_expanded
  persona_src_expanded="$(expand_includes "$persona_src" "$overlay_name" "$persona_shared_root" \
    "$include_root" "$include_prefer_repo" "$include_extra_paths" "$include_persona_home" "$persona")"

  # Find and merge meta
  local repo_root meta_path=""
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"
  local repo_shared_root="$repo_root/.personas/.shared"

  if [[ "$META_ENABLED" != "0" ]]; then
    if [[ -n "$META_FILE_OVERRIDE" ]]; then
      meta_path="$META_FILE_OVERRIDE"
      [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
      if [[ -f "$meta_path" ]]; then
        meta_is_unedited_template "$meta_path" && meta_path=""
      else
        meta_path=""
      fi
    else
      for cand in ".personas/.shared/meta.AGENTS.md" ".personas/.shared/meta.agents.md" \
        ".personas/meta.AGENTS.md" ".personas/meta.agents.md" \
        ".persona/.shared/meta.AGENTS.md" ".persona/.shared/meta.agents.md" \
        ".persona/meta.AGENTS.md" ".persona/meta.agents.md" \
        "meta.AGENTS.md" "meta.agents.md"; do
        cand_path="$repo_root/$cand"
        if [[ -f "$cand_path" ]]; then
          if meta_is_unedited_template "$cand_path"; then
            log "skipping unedited meta template: $cand_path"
            continue
          fi
          meta_path="$cand_path"
          break
        fi
      done
    fi
  fi

  # Determine which instruction file type is being used
  local instruction_type="default"
  [[ "$persona_src" == *"/$overlay_name" && "$overlay_name" != "AGENTS.md" ]] && instruction_type="tool-specific"

  echo "# === COMPOSED OVERLAY: $overlay_name ==="
  echo "# Persona dir: $persona_dir"
  echo "# Instruction: $persona_src ($instruction_type)"
  [[ -n "$meta_path" ]] && echo "# Meta: $meta_path (position: $META_POSITION)"
  echo ""

  local meta_src_expanded=""
  if [[ -n "$meta_path" ]]; then
    meta_src_expanded="$(expand_includes "$meta_path" "$overlay_name" "$repo_shared_root" \
      "$include_root" "$include_prefer_repo" "$include_extra_paths" "$include_persona_home" "$persona")"
  fi

  if [[ -n "$meta_path" && "$META_POSITION" == "top" ]]; then
    echo "<!-- meta -->"
    cat "$meta_src_expanded"
    echo ""
    echo "<!-- /meta -->"
    echo ""
  fi

  echo "<!-- persona -->"
  cat "$persona_src_expanded"
  echo ""
  echo "<!-- /persona -->"

  if [[ -n "$meta_path" && "$META_POSITION" == "bottom" ]]; then
    echo ""
    echo "<!-- meta -->"
    cat "$meta_src_expanded"
    echo ""
    echo "<!-- /meta -->"
  fi
}

# --- Subcommand: list ---
cmd_list() {
  local root="${AGENT_PERSONA_ROOT:-$(pwd)}"
  cd "$root" 2>/dev/null || die "unable to cd to root: $root"
  root="$(pwd -P)"

  local PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
  local PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
  local EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

  local found=0

  _list_from_base() {
    local base="$1" label="$2" d slug
    [[ -d "$base" ]] || return 0
    for d in "$base"/*; do
      [[ -d "$d" && -f "$d/AGENTS.md" ]] || continue
      slug="$(basename -- "$d")"
      printf '%s\t%s\t%s\n' "$slug" "$label" "$d"
      found=1
    done
  }

  printf 'PERSONA\tSOURCE\tPATH\n'

  _list_repo_upwards() {
    local dir="$1"
    while true; do
      _list_from_base "$dir/.personas" repo
      _list_from_base "$dir/.persona" repo
      [[ "$dir" == "/" ]] && break
      dir="$(dirname -- "$dir")"
    done
  }

  if [[ "$PREFER_REPO" == "1" ]]; then
    _list_repo_upwards "$root"
  fi

  if [[ -n "$EXTRA_PATHS" ]]; then
    IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
    for p in "${arr[@]:-}"; do [[ -n "$p" ]] && _list_from_base "$p" paths; done
  fi

  _list_from_base "$HOME/.personas" home
  _list_from_base "$PERSONA_HOME/.personas" user
  _list_from_base "/usr/local/share/agent-persona/.personas" system

  if [[ $found -eq 0 ]]; then
    echo "(no personas found)" >&2
    exit 1
  fi
}

# --- Usage ---
usage() {
  cat >&2 <<USAGE
agent-persona v$VERSION â€” tool-agnostic persona launcher for AI coding agents

USAGE:
  agent-persona <tool> <persona> [--] [tool args...]
  agent-persona init [path]           Scaffold .personas/ in a repo
  agent-persona doctor                Verify installation and state
  agent-persona recover               Restore files after hard-kill
  agent-persona which <persona>       Show resolved paths (no launch)
  agent-persona print-overlay <t> <p> Show composed overlay (dry-run)
  agent-persona print-policy <t> <p>  Show policy translation summary
  agent-persona --list                List available personas

TOOLS:
  codex, claude, claude-code, gemini, opencode
  Or any executable on PATH

FLAGS:
  --no-meta                 Skip repo meta merge (.personas/.shared/meta.AGENTS.md)
  --no-mcp                  Skip MCP injection from persona.json
  --no-defaults             Skip persona/tool defaults injection
  --meta-file=<path>        Override meta file path
  --meta-position=top|bottom  Where to merge meta (default: top)
  --force-swap              Force swap-and-restore (skip unshare)
  --strict-policy           Enforce policy and fail if it cannot be enforced
  --version                 Show version
  -h, --help                Show this help

ENVIRONMENT:
  AGENT_PERSONA_DEBUG=1             Enable debug logging
  AGENT_PERSONA_META=0              Disable meta merge
  AGENT_PERSONA_META_FILE=<path>    Override meta file
  AGENT_PERSONA_META_POSITION=...   top or bottom
  AGENT_PERSONA_FORCE_SWAP=1        Force swap mode
  AGENT_PERSONA_MCP=0               Disable MCP injection
  AGENT_PERSONA_DEFAULTS=0          Disable persona/tool defaults
  AGENT_PERSONA_STRICT_POLICY=1     Enforce policy and fail if it cannot be enforced
  AGENT_PERSONA_GEMINI_DISABLE_IDE=1  Disable Gemini IDE mode
  AGENT_PERSONA_GEMINI_FORCE_TTY=auto  Force pseudo-TTY for Gemini (auto|1|0)
  AGENT_PERSONA_INCLUDE_DEPTH=10    Max include recursion depth
  AGENT_PERSONA_PATHS=<p1:p2:...>   Extra search paths
  AGENT_PERSONA_HOME=<path>         Persona home (contains .personas/)
  AGENT_PERSONA_UPDATE_CHECK=0      Disable update checking
  AGENT_PERSONA_UPDATE_CHECK_INTERVAL=86400  Check interval in seconds (default: 24h)

EXPORTED TO TOOL (v1.1+):
  AGENT_PERSONA_NAME          Persona slug (e.g., "code-reviewer")
  AGENT_PERSONA_PATH          Resolved persona directory path
  AGENT_PERSONA_TOOL          Tool being launched (claude, codex, etc.)
  AGENT_PERSONA_OVERLAY_FILE  Target overlay file (CLAUDE.md, AGENTS.md, etc.)
  AGENT_PERSONA_RUN_MODE      Launch mode (unshare or swap)

OVERLAY BEHAVIOR:
  Linux with unprivileged user namespaces:
    Uses bind-mount via unshare. No on-disk changes.

  Otherwise (or with --force-swap):
    Swap-and-restore: backs up existing file, copies persona,
    restores on exit. Small risk on hard-kill (SIGKILL/crash).
    Use 'agent-persona recover' to restore after hard-kill.

REPO META:
  If .personas/.shared/meta.AGENTS.md matches the init template, it is ignored until you edit it.

EXAMPLES:
  agent-persona claude blank          # Launch Claude with blank persona
  agent-persona codex my-agent        # Launch Codex with my-agent persona
  agent-persona init                  # Setup .personas/ in current repo
  agent-persona which my-agent        # Check where persona resolves from
USAGE
}

# --- Main argument parsing ---
invoked="$(basename -- "$0")"
tool=""
case "$invoked" in
  codex-persona) tool="codex";;
  opencode-persona) tool="opencode";;
  claude-persona) tool="claude";;
  gemini-persona) tool="gemini";;
esac

persona=""
pass_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    # Subcommands
    init)
      shift; cmd_init "$@"; exit $?
      ;;
    doctor)
      cmd_doctor; exit $?
      ;;
    recover)
      cmd_recover; exit $?
      ;;
    which|explain)
      shift
      cmd_which "$@"; exit $?
      ;;
    print-overlay|--dry-run)
      shift
      cmd_print_overlay "$@"; exit $?
      ;;
    print-policy)
      shift
      cmd_print_policy "$@"; exit $?
      ;;

    # Flags
    -l|--list)
      cmd_list; exit $?
      ;;
    --version|-V)
      echo "agent-persona $VERSION"
      exit 0
      ;;
    -h|--help)
      usage; exit 0
      ;;
    --no-meta)
      META_ENABLED="0"; shift
      ;;
    --no-mcp)
      MCP_ENABLED="0"; shift
      ;;
    --no-defaults)
      DEFAULTS_ENABLED="0"; shift
      ;;
    --meta-file=*)
      META_FILE_OVERRIDE="${1#*=}"; shift
      ;;
    --meta-file)
      shift
      [[ $# -gt 0 ]] || die "--meta-file requires a value"
      META_FILE_OVERRIDE="$1"; shift
      ;;
    --meta-position=*)
      META_POSITION="${1#*=}"; shift
      ;;
    --meta-position)
      shift
      [[ $# -gt 0 ]] || die "--meta-position requires a value"
      META_POSITION="$1"; shift
      ;;
    --force-swap|--no-unshare)
      FORCE_SWAP="1"; shift
      ;;
    --strict-policy)
      STRICT_POLICY="1"; shift
      ;;
    --tool)
      shift; [[ $# -gt 0 ]] || die "--tool requires a value"
      tool="$1"; shift
      ;;
    --tool=*)
      tool="${1#*=}"; shift
      ;;
    --)
      shift; pass_args=("$@"); break
      ;;
    -*)
      # Unknown flag - pass through to tool
      pass_args+=("$1"); shift
      ;;
    *)
      # Positional: tool (if not set), then persona, then pass-through
      if [[ -z "$tool" ]]; then
        cand="$1"
        if command -v "$cand" >/dev/null 2>&1 || [[ "$cand" =~ ^(codex|opencode|claude|claude-code|gemini)$ ]]; then
          tool="$cand"; shift; continue
        fi
      fi
      if [[ -z "$persona" ]]; then
        persona="$1"; shift
      else
        pass_args+=("$1"); shift
      fi
      ;;
  esac
done

# Validate
[[ -n "$persona" ]] || { usage; exit 2; }
[[ -n "$tool" ]] || die "tool required. Use: agent-persona <tool> <persona>"

# Check for updates (non-blocking background check)
check_for_updates

# --- Resolve working root ---
root="${AGENT_PERSONA_ROOT:-$(pwd)}"
cd "$root"
root="$(pwd -P)"

# --- gitguard (repo-local git safety wrapper) ---
repo_root=""
if command -v git >/dev/null 2>&1; then
  repo_root="$(git -C \"$root\" rev-parse --show-toplevel 2>/dev/null || true)"
fi
if [[ -n "${repo_root:-}" && -d "$repo_root/Scripts/gitguard/bin" ]]; then
  export PATH="$repo_root/Scripts/gitguard/bin:$PATH"
fi

# --- Resolve persona ---
PREFER_REPO="${AGENT_PERSONA_PREFER_REPO:-1}"
PERSONA_HOME="${AGENT_PERSONA_HOME:-$HOME/.local/share/agent-persona}"
EXTRA_PATHS="${AGENT_PERSONA_PATHS:-}"

profile_type=""
persona_src=""

try_resolve_persona_dir() {
  local base="$1"
  if [[ -f "$base/$persona/AGENTS.md" ]]; then
    profile_type="file"; persona_src="$base/$persona/AGENTS.md"; return 0
  elif [[ -d "$base/$persona" && -f "$base/$persona/AGENTS.md" ]]; then
    profile_type="dir"; persona_src="$base/$persona"; return 0
  fi
  return 1
}

_scan_repo_upwards() {
  local dir="$1"
  while true; do
    try_resolve_persona_dir "$dir/.personas" && return 0
    try_resolve_persona_dir "$dir/.persona" && return 0
    [[ "$dir" == "/" ]] && break
    dir="$(dirname -- "$dir")"
  done
  return 1
}

# Resolution order
if [[ "$PREFER_REPO" == "1" ]]; then
  _scan_repo_upwards "$root" || true
fi

if [[ -z "$persona_src" && -n "$EXTRA_PATHS" ]]; then
  IFS=':' read -r -a arr <<<"$EXTRA_PATHS"
  for p in "${arr[@]:-}"; do
    [[ -n "$p" ]] && try_resolve_persona_dir "$p" && break
  done
fi

if [[ -z "$persona_src" ]]; then
  try_resolve_persona_dir "$HOME/.personas" || \
  try_resolve_persona_dir "$PERSONA_HOME/.personas" || \
  try_resolve_persona_dir "/usr/local/share/agent-persona/.personas" || true
fi

if [[ -z "$persona_src" && "$PREFER_REPO" != "1" ]]; then
  _scan_repo_upwards "$root" || true
fi

[[ -n "$persona_src" ]] || die "persona '$persona' not found"

log "persona source: $persona_src"

# --- Normalize persona directory (handles file-vs-dir profiles) ---
persona_dir="$(get_persona_dir "$persona_src" "$profile_type")"

# --- Ensure README.md exists in repo persona directory ---
ensure_persona_dir_readme "$persona_dir"

# --- Determine overlay filename (moved earlier for per-tool instruction support) ---
overlay_name="AGENTS.md"
case "$tool" in
  claude|claude-code) overlay_name="CLAUDE.md" ;;
  gemini) overlay_name="GEMINI.md" ;;
esac

# --- Resolve instruction file (tool-specific or fallback to AGENTS.md) ---
link_target="$(resolve_instruction_file "$persona_dir" "$overlay_name")"
[[ -f "$link_target" ]] || die "persona instructions not found: $link_target"
log "instruction file: $link_target"

# --- Export persona metadata for tracing/logging/memory ---
export AGENT_PERSONA_NAME="$persona"
export AGENT_PERSONA_PATH="$persona_dir"
export AGENT_PERSONA_TOOL="$tool"
export AGENT_PERSONA_OVERLAY_FILE="$overlay_name"
# AGENT_PERSONA_RUN_MODE is set just before each launch path

# --- Load per-tool defaults from persona.json ---
json_cfg=""
base_dir="$persona_dir"
for cand in "$base_dir/persona.json" "$base_dir/Persona.json" "$base_dir/config.json"; do
  [[ -f "$cand" ]] && { json_cfg="$cand"; break; }
done

json_cfg_resolved="$json_cfg"
if [[ -n "$json_cfg" ]]; then
  json_cfg_resolved="$(resolve_persona_json "$json_cfg" "$persona_dir" "$root" "$PREFER_REPO" "$EXTRA_PATHS" "$PERSONA_HOME")"
  [[ -n "$json_cfg_resolved" ]] || json_cfg_resolved="$json_cfg"
fi

defaults=()
if [[ "$DEFAULTS_ENABLED" != "0" && -n "$json_cfg_resolved" ]]; then
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    defaults+=( "$line" )
  done < <(defaults_from_json "$json_cfg_resolved" "$tool")
fi

# --- Detect policy in persona.json ---
has_policy=0
if [[ -n "$json_cfg_resolved" ]] && policy_exists_in_json "$json_cfg_resolved"; then
  has_policy=1
  log "policy detected in persona.json"

  # Policy requires Python for translation
  if ! command -v python3 >/dev/null 2>&1 && ! command -v python >/dev/null 2>&1; then
    die "policy defined in persona.json but Python not available (required for enforcement)"
  fi
fi

# --- Tool-specific defaults (suppressed when policy exists) ---
tool_cmd="$tool"
case "$tool" in
  claude|claude-code)
    if command -v claude >/dev/null 2>&1; then
      tool_cmd="claude"
    elif command -v claude-code >/dev/null 2>&1; then
      tool_cmd="claude-code"
    fi
    if [[ "$DEFAULTS_ENABLED" != "0" ]]; then
      # Default permission mode (skip if policy exists - policy controls permissions)
      if [[ $has_policy -eq 0 ]]; then
        has_perm=0
        for a in "${pass_args[@]}" "${defaults[@]}"; do
          [[ "$a" == "--permission-mode"* || "$a" == "--dangerously-skip-permissions" ]] && has_perm=1
        done
        [[ $has_perm -eq 0 ]] && defaults+=(--permission-mode bypassPermissions)
      else
        log "policy present, skipping default --permission-mode bypassPermissions"
      fi
    else
      log "defaults disabled, skipping Claude permission default"
    fi
    ;;
  codex)
    if [[ "$DEFAULTS_ENABLED" != "0" ]]; then
      # Default to --full-auto unless already specified (skip if policy exists)
      if [[ $has_policy -eq 0 ]]; then
        has_auto=0
        for a in "${pass_args[@]}" "${defaults[@]}"; do
          [[ "$a" == "--full-auto" || "$a" == "--yolo" || "$a" == "--dangerously-bypass-approvals-and-sandbox" ]] && has_auto=1
        done
        [[ $has_auto -eq 0 ]] && defaults+=(--full-auto)
      else
        log "policy present, skipping default --full-auto"
      fi
    else
      log "defaults disabled, skipping Codex auto default"
    fi
    ;;
esac

# --- MCP servers (persona.json) ---
if [[ "$MCP_ENABLED" != "0" && -n "$json_cfg_resolved" && "$tool" == "codex" ]]; then
  while IFS= read -r ov; do
    [[ -n "$ov" ]] || continue
    defaults+=( -c "$ov" )
  done < <(codex_mcp_overrides_from_json "$json_cfg_resolved")
fi

if [[ "$MCP_ENABLED" != "0" && -n "$json_cfg_resolved" && ( "$tool" == "claude" || "$tool" == "claude-code" ) ]]; then
  have_mcp_config=0
  for a in "${pass_args[@]}" "${defaults[@]}"; do
    [[ "$a" == "--mcp-config" || "$a" == --mcp-config=* ]] && have_mcp_config=1
  done
  if [[ $have_mcp_config -eq 0 ]]; then
    mcp_config_file="$(extract_mcp_config "$json_cfg_resolved")" || mcp_config_file=""
    if [[ -n "$mcp_config_file" && -f "$mcp_config_file" ]]; then
      log "MCP config extracted to: $mcp_config_file"
      defaults+=( --mcp-config "$mcp_config_file" )
    fi
  fi
fi

# --- Policy translation (populate policy_args for enforcement) ---
policy_args=()
if [[ $has_policy -eq 1 && -n "$json_cfg_resolved" ]]; then
  log "translating policy for tool: $tool"

  case "$tool" in
    claude|claude-code)
      # tools.allow -> --allowedTools (comma-separated)
      mapfile -t allowed_tools < <(policy_tools_allow "$json_cfg_resolved" "claude")
      if (( ${#allowed_tools[@]} > 0 )); then
        allowed_csv=$(IFS=','; echo "${allowed_tools[*]}")
        policy_args+=(--allowedTools "$allowed_csv")
        log "policy: --allowedTools $allowed_csv"
      fi

      # tools.deny -> --disallowedTools
      mapfile -t denied_tools < <(policy_tools_deny "$json_cfg_resolved" "claude")
      if (( ${#denied_tools[@]} > 0 )); then
        denied_csv=$(IFS=','; echo "${denied_tools[*]}")
        policy_args+=(--disallowedTools "$denied_csv")
        log "policy: --disallowedTools $denied_csv"
      fi

      # paths.deny -> --settings (temp JSON file)
      claude_settings_file="$(generate_claude_settings "$json_cfg_resolved")" || claude_settings_file=""
      if [[ -n "$claude_settings_file" && -f "$claude_settings_file" ]]; then
        policy_args+=(--settings "$claude_settings_file")
        log "policy: --settings $claude_settings_file"
      fi
      ;;

    codex)
      # Generate sandbox overrides
      while IFS= read -r ov; do
        [[ -n "$ov" ]] || continue
        policy_args+=(-c "$ov")
        log "policy: -c $ov"
      done < <(codex_policy_overrides "$json_cfg_resolved" "$root")
      ;;

    gemini)
      # Generate settings file and set env var (strict-policy enforces; otherwise allow user override via existing env)
      if [[ "$STRICT_POLICY" == "1" || -z "${GEMINI_CLI_SYSTEM_SETTINGS_PATH:-}" ]]; then
        gemini_settings_file="$(generate_gemini_settings "$json_cfg_resolved")" || gemini_settings_file=""
        if [[ -n "$gemini_settings_file" && -f "$gemini_settings_file" ]]; then
          export GEMINI_CLI_SYSTEM_SETTINGS_PATH="$gemini_settings_file"
          log "policy: GEMINI_CLI_SYSTEM_SETTINGS_PATH=$gemini_settings_file"
        fi
      else
        log "policy: GEMINI_CLI_SYSTEM_SETTINGS_PATH already set; skipping policy settings injection"
      fi
      ;;

    opencode)
      # Generate config file and set env var (strict-policy enforces; otherwise allow user override via existing env)
      if [[ "$STRICT_POLICY" == "1" || -z "${OPENCODE_CONFIG:-}" ]]; then
        opencode_config_file="$(generate_opencode_config "$json_cfg_resolved")" || opencode_config_file=""
        if [[ -n "$opencode_config_file" && -f "$opencode_config_file" ]]; then
          export OPENCODE_CONFIG="$opencode_config_file"
          log "policy: OPENCODE_CONFIG=$opencode_config_file"
        fi
      else
        log "policy: OPENCODE_CONFIG already set; skipping policy config injection"
      fi
      ;;

    *)
      # Unknown tool - warn if policy exists
      warn "policy defined but tool '$tool' does not have policy translation support"
      ;;
  esac

  # Strict policy enforcement check
  if [[ "$STRICT_POLICY" == "1" ]]; then
    check_strict_policy "$tool" "$json_cfg_resolved"
  fi
fi

# --- Expand include directives in persona instructions ---
persona_shared_root="$(dirname "$persona_dir")/.shared"
link_target="$(expand_includes "$link_target" "$overlay_name" "$persona_shared_root" \
  "$root" "$PREFER_REPO" "$EXTRA_PATHS" "$PERSONA_HOME" "$persona")"

# --- Merge repo meta if present ---
meta_files=()
if [[ "$META_ENABLED" != "0" ]]; then
  repo_root="$(resolve_repo_root 2>/dev/null || echo "$root")"
  repo_shared_root="$repo_root/.personas/.shared"

  if [[ -n "$META_FILE_OVERRIDE" ]]; then
    meta_path="$META_FILE_OVERRIDE"
    [[ "$meta_path" == /* ]] || meta_path="$repo_root/$meta_path"
    if [[ -f "$meta_path" ]]; then
      if meta_is_unedited_template "$meta_path"; then
        log "skipping unedited meta template: $meta_path"
      else
        meta_files+=("$meta_path")
      fi
    fi
  else
    for cand in ".personas/.shared/meta.AGENTS.md" ".personas/.shared/meta.agents.md" \
      ".personas/meta.AGENTS.md" ".personas/meta.agents.md" \
      ".persona/.shared/meta.AGENTS.md" ".persona/.shared/meta.agents.md" \
      ".persona/meta.AGENTS.md" ".persona/meta.agents.md" \
      "meta.AGENTS.md" "meta.agents.md"; do
      cand_path="$repo_root/$cand"
      if [[ -f "$cand_path" ]]; then
        if meta_is_unedited_template "$cand_path"; then
          log "skipping unedited meta template: $cand_path"
          continue
        fi
        meta_files+=("$cand_path")
        break
      fi
    done
  fi
fi

if (( ${#meta_files[@]} > 0 )); then
  meta_files_expanded=()
  for p in "${meta_files[@]}"; do
    meta_files_expanded+=( "$(expand_includes "$p" "$overlay_name" "$repo_shared_root" \
      "$root" "$PREFER_REPO" "$EXTRA_PATHS" "$PERSONA_HOME" "$persona")" )
  done

  meta_tmp="$(mktemp -p "${TMPDIR:-/tmp}" "agent-persona.${overlay_name}.XXXXXX")"

  case "$META_POSITION" in
    top|prepend|before)
      {
        for p in "${meta_files_expanded[@]}"; do
          echo "<!-- meta -->"
          cat "$p"
          echo -e "\n<!-- /meta -->\n"
        done
        echo "<!-- persona -->"
        cat "$link_target"
        echo -e "\n<!-- /persona -->"
      } > "$meta_tmp"
      ;;
    bottom|append|after)
      {
        echo "<!-- persona -->"
        cat "$link_target"
        echo -e "\n<!-- /persona -->\n"
        for p in "${meta_files_expanded[@]}"; do
          echo "<!-- meta -->"
          cat "$p"
          echo -e "\n<!-- /meta -->"
        done
      } > "$meta_tmp"
      ;;
    *)
      die "invalid meta position: $META_POSITION (expected: top|bottom)"
      ;;
  esac

  link_target="$meta_tmp"
  log "meta merged ($META_POSITION): ${meta_files[*]}"
fi

# --- Build final args (defaults + policy + user; strict-policy flips precedence) ---
# Precedence in normal mode: user args > policy > defaults
# Precedence in strict-policy: policy > user args > defaults (policy-controlled user flags are removed)

# User tool args (may be filtered in strict-policy)
user_args=("${pass_args[@]}")
filtered_user_args=("${pass_args[@]}")
if [[ $has_policy -eq 1 && "$STRICT_POLICY" == "1" ]]; then
  mapfile -d '' filtered_user_args < <(filter_user_args "$tool" "$has_policy" "${pass_args[@]}")
fi

# Filter defaults when user overrides them (ensures user args win even for first-match CLIs)
default_args=("${defaults[@]}")
if (( ${#filtered_user_args[@]} > 0 && ${#default_args[@]} > 0 )); then
  mapfile -d '' default_args < <(filter_defaults_by_user_overrides "$tool" "${default_args[@]}" -- "${filtered_user_args[@]}")
fi

# Filter policy args when user overrides them (normal mode only; ensures user args win even for first-match CLIs)
policy_args_effective=("${policy_args[@]}")
if [[ $has_policy -eq 1 && "$STRICT_POLICY" != "1" ]]; then
  if (( ${#filtered_user_args[@]} > 0 && ${#policy_args_effective[@]} > 0 )); then
    mapfile -d '' policy_args_effective < <(filter_defaults_by_user_overrides "$tool" "${policy_args_effective[@]}" -- "${filtered_user_args[@]}")
  fi
fi

# Ensure policy overrides defaults regardless of tool precedence behavior
if (( ${#policy_args_effective[@]} > 0 && ${#default_args[@]} > 0 )); then
  mapfile -d '' default_args < <(filter_defaults_by_user_overrides "$tool" "${default_args[@]}" -- "${policy_args_effective[@]}")
fi

if [[ $has_policy -eq 1 && "$STRICT_POLICY" == "1" ]]; then
  # Strict-policy: enforce policy (policy args come last)
  tool_args=("${default_args[@]}" "${filtered_user_args[@]}" "${policy_args_effective[@]}")
else
  # Normal: user args override policy
  tool_args=("${default_args[@]}" "${policy_args_effective[@]}" "${filtered_user_args[@]}")
fi

# --- Gemini: normalize non-TTY runs via pseudo-PTY (script) ---
gemini_wrapper_ready=0
gemini_use_pty=0
gemini_force_requested=0
if [[ "$tool" == "gemini" ]]; then
  case "${GEMINI_FORCE_TTY,,}" in
    1|true|yes)
      gemini_use_pty=1
      gemini_force_requested=1
      ;;
    0|false|no)
      gemini_use_pty=0
      ;;
    auto|"")
      [[ ! -t 1 ]] && gemini_use_pty=1
      ;;
    *)
      warn "unknown AGENT_PERSONA_GEMINI_FORCE_TTY value: $GEMINI_FORCE_TTY (expected: auto|1|0)"
      ;;
  esac

  if [[ $gemini_use_pty -eq 1 ]]; then
    if command -v script >/dev/null 2>&1; then
      if ! script -q -c /bin/true /dev/null >/dev/null 2>&1; then
        if [[ $gemini_force_requested -eq 1 ]]; then
          die "gemini: requested pseudo-TTY but 'script' cannot allocate a PTY; run in a real TTY or set AGENT_PERSONA_GEMINI_FORCE_TTY=0"
        fi
        warn "gemini: unable to allocate a PTY with 'script'; running without PTY (gemini may hang)"
        gemini_use_pty=0
      else
        gemini_wrapper_file="$(mktemp -p "$STATE_DIR" "agent-persona.gemini-run.XXXXXX")"
        {
          echo "#!/usr/bin/env bash"
          echo "set -euo pipefail"
          printf "exec %q" "$tool_cmd"
          for arg in "${tool_args[@]}"; do
            printf " %q" "$arg"
          done
          echo ""
        } > "$gemini_wrapper_file"
        chmod +x "$gemini_wrapper_file"
        gemini_wrapper_ready=1
        log "gemini: wrapping with script for pseudo-TTY"
      fi
    else
      if [[ $gemini_force_requested -eq 1 ]]; then
        die "gemini: requested pseudo-TTY but 'script' is unavailable; install util-linux or set AGENT_PERSONA_GEMINI_FORCE_TTY=0"
      fi
      warn "gemini: stdout is not a TTY and 'script' is unavailable; gemini may hang (install util-linux)"
      gemini_use_pty=0
    fi
  fi
fi

quote_join() {
  local out="" q
  for x in "$@"; do printf -v q '%q' "$x"; out+="$q "; done
  printf '%s' "$out"
}

# --- Strategy 1: bind-mount via unshare (preferred) ---
launch_ok=0
args_quoted="$(quote_join "${tool_args[@]}")"

if [[ "$FORCE_SWAP" != "1" ]] && command -v unshare >/dev/null 2>&1; then
  export AGENT_PERSONA_RUN_MODE="unshare"
  set +e
  tmp_err="$(mktemp)"
  unshare -Um bash -lc "set -euo pipefail
    root_dir=$(printf '%q' "$root")
    persona_file=$(printf '%q' "$link_target")
    agents_path=$(printf '%q' "$root/$overlay_name")

    created=0
    if [[ ! -e \"\$agents_path\" ]]; then
      touch \"\$agents_path\"
      created=1
    fi

    cleanup() {
      umount \"\$agents_path\" 2>/dev/null || true
      [[ \$created -eq 1 ]] && rm -f \"\$agents_path\"
    }
    trap cleanup EXIT INT TERM

    mount --bind \"\$persona_file\" \"\$agents_path\"
    cd \"\$root_dir\"

    if command -v $(printf '%q' "$tool_cmd") >/dev/null 2>&1; then
      if [[ $gemini_use_pty -eq 1 && $gemini_wrapper_ready -eq 1 ]]; then
        if command -v script >/dev/null 2>&1; then
          script -q -c $(printf '%q' "$gemini_wrapper_file") /dev/null
        else
          $(printf '%q' "$gemini_wrapper_file")
        fi
      else
        $(printf '%q' "$tool_cmd") $args_quoted
      fi
    else
      echo 'tool not found: $tool_cmd' >&2
      exit 127
    fi
  " 2>"$tmp_err"
  rc=$?
  set -e

  if [[ $rc -eq 0 ]]; then
    launch_ok=1
  else
    log "unshare failed (rc=$rc): $(<"$tmp_err")"
  fi
  rm -f "$tmp_err" 2>/dev/null || true
fi

# --- Strategy 2: swap-and-restore (fallback) ---
if [[ $launch_ok -eq 0 ]]; then
  export AGENT_PERSONA_RUN_MODE="swap"
  log "using swap-and-restore mode"

  swap_prev_kind="none"
  swap_prev_target=""
  swap_prev_backup=""
  swap_backup_meta=""
  swap_overlay_path="$root/$overlay_name"

  # Save current state
  if [[ -L "$swap_overlay_path" ]]; then
    swap_prev_kind="symlink"
    swap_prev_target="$(readlink "$swap_overlay_path" || true)"
  elif [[ -f "$swap_overlay_path" ]]; then
    swap_prev_kind="file"
    swap_prev_backup="$(mktemp -p "$STATE_DIR" "agent-persona.${overlay_name}.XXXXXX.backup")"
    swap_backup_meta="${swap_prev_backup%.backup}.meta"
    cp -a "$swap_overlay_path" "$swap_prev_backup"
    echo "$swap_overlay_path" > "$swap_backup_meta"
  fi

  swap_active=1
  swap_restored=0

  # Copy persona to overlay location
  if ! cp -a --remove-destination "$link_target" "$swap_overlay_path" 2>/dev/null; then
    rm -f "$swap_overlay_path" 2>/dev/null || true
    cp -a "$link_target" "$swap_overlay_path" || die "failed to copy persona"
  fi

  cd "$root"
  if command -v "$tool_cmd" >/dev/null 2>&1; then
    if [[ $gemini_use_pty -eq 1 && $gemini_wrapper_ready -eq 1 ]]; then
      if command -v script >/dev/null 2>&1; then
        script -q -c "$gemini_wrapper_file" /dev/null
      else
        "$gemini_wrapper_file"
      fi
    else
      "$tool_cmd" "${tool_args[@]}"
    fi
    launch_ok=1
  else
    die "tool not found: $tool_cmd"
  fi

  swap_restore
fi

[[ $launch_ok -eq 1 ]] || die "failed to launch"
